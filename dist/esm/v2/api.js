/* tslint:disable */
/* eslint-disable */
/**
 * MITx Online API
 * MIT public API
 *
 * The version of the OpenAPI document: 0.0.1 (v2)
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, operationServerMap } from './base';
/**
 * * `anytime` - anytime * `dated` - dated
 * @export
 * @enum {string}
 */
export const AvailabilityEnum = {
    /**
    * anytime
    */
    Anytime: 'anytime',
    /**
    * dated
    */
    Dated: 'dated'
};
/**
 *
 * @export
 * @enum {string}
 */
export const BlankEnum = {
    Empty: ''
};
/**
 * * `None` - ---- * `1` - Small/Start-up (1+ employees) * `9` - Small/Home office (1-9 employees) * `99` - Small (10-99 employees) * `999` - Small to medium-sized (100-999 employees) * `9999` - Medium-sized (1000-9999 employees) * `10000` - Large Enterprise (10,000+ employees) * `0` - Other (N/A or Don\'t know)
 * @export
 * @enum {string}
 */
export const CompanySizeEnum = {
    /**
    * Small/Start-up (1+ employees)
    */
    NUMBER_1: 1,
    /**
    * Small/Home office (1-9 employees)
    */
    NUMBER_9: 9,
    /**
    * Small (10-99 employees)
    */
    NUMBER_99: 99,
    /**
    * Small to medium-sized (100-999 employees)
    */
    NUMBER_999: 999,
    /**
    * Medium-sized (1000-9999 employees)
    */
    NUMBER_9999: 9999,
    /**
    * Large Enterprise (10,000+ employees)
    */
    NUMBER_10000: 10000,
    /**
    * Other (N/A or Don&#39;t know)
    */
    NUMBER_0: 0
};
/**
 * * `percent-off` - percent-off * `dollars-off` - dollars-off * `fixed-price` - fixed-price
 * @export
 * @enum {string}
 */
export const DiscountTypeEnum = {
    /**
    * percent-off
    */
    PercentOff: 'percent-off',
    /**
    * dollars-off
    */
    DollarsOff: 'dollars-off',
    /**
    * fixed-price
    */
    FixedPrice: 'fixed-price'
};
/**
 * * `audit` - audit * `verified` - verified
 * @export
 * @enum {string}
 */
export const EnrollmentModeEnum = {
    /**
    * audit
    */
    Audit: 'audit',
    /**
    * verified
    */
    Verified: 'verified'
};
/**
 * * `enroll-blocked` - enroll-blocked * `enroll-duplicated` - enroll-duplicated * `course-non-upgradable` - course-non-upgradable * `discount-invalid` - discount-invalid * `b2b-error-missing-enrollment-code` - b2b-error-missing-enrollment-code * `b2b-invalid-basket` - b2b-invalid-basket * `basket-empty` - basket-empty
 * @export
 * @enum {string}
 */
export const ErrorEnum = {
    /**
    * enroll-blocked
    */
    EnrollBlocked: 'enroll-blocked',
    /**
    * enroll-duplicated
    */
    EnrollDuplicated: 'enroll-duplicated',
    /**
    * course-non-upgradable
    */
    CourseNonUpgradable: 'course-non-upgradable',
    /**
    * discount-invalid
    */
    DiscountInvalid: 'discount-invalid',
    /**
    * b2b-error-missing-enrollment-code
    */
    B2bErrorMissingEnrollmentCode: 'b2b-error-missing-enrollment-code',
    /**
    * b2b-invalid-basket
    */
    B2bInvalidBasket: 'b2b-invalid-basket',
    /**
    * basket-empty
    */
    BasketEmpty: 'basket-empty'
};
/**
 * * `m` - Male * `f` - Female * `t` - Transgender * `nb` - Non-binary/non-conforming * `o` - Other/Prefer Not to Say
 * @export
 * @enum {string}
 */
export const GenderEnum = {
    /**
    * Male
    */
    M: 'm',
    /**
    * Female
    */
    F: 'f',
    /**
    * Transgender
    */
    T: 't',
    /**
    * Non-binary/non-conforming
    */
    Nb: 'nb',
    /**
    * Other/Prefer Not to Say
    */
    O: 'o'
};
/**
 * * `None` - ---- * `Doctorate` - Doctorate * `Master\'s or professional degree` - Master\'s or professional degree * `Bachelor\'s degree` - Bachelor\'s degree * `Associate degree` - Associate degree * `Secondary/high school` - Secondary/high school * `Junior secondary/junior high/middle school` - Junior secondary/junior high/middle school * `Elementary/primary school` - Elementary/primary school * `No formal education` - No formal education * `Other education` - Other education
 * @export
 * @enum {string}
 */
export const HighestEducationEnum = {
    /**
    * Doctorate
    */
    Doctorate: 'Doctorate',
    /**
    * Master&#39;s or professional degree
    */
    MastersOrProfessionalDegree: 'Master\'s or professional degree',
    /**
    * Bachelor&#39;s degree
    */
    BachelorsDegree: 'Bachelor\'s degree',
    /**
    * Associate degree
    */
    AssociateDegree: 'Associate degree',
    /**
    * Secondary/high school
    */
    SecondaryHighSchool: 'Secondary/high school',
    /**
    * Junior secondary/junior high/middle school
    */
    JuniorSecondaryJuniorHighMiddleSchool: 'Junior secondary/junior high/middle school',
    /**
    * Elementary/primary school
    */
    ElementaryPrimarySchool: 'Elementary/primary school',
    /**
    * No formal education
    */
    NoFormalEducation: 'No formal education',
    /**
    * Other education
    */
    OtherEducation: 'Other education'
};
/**
 * * `sso` - SSO * `non-sso` - Non-SSO * `managed` - Managed * `code` - Enrollment Code * `auto` - Auto Enrollment
 * @export
 * @enum {string}
 */
export const IntegrationTypeEnum = {
    /**
    * SSO
    */
    Sso: 'sso',
    /**
    * Non-SSO
    */
    NonSso: 'non-sso',
    /**
    * Managed
    */
    Managed: 'managed',
    /**
    * Enrollment Code
    */
    Code: 'code',
    /**
    * Auto Enrollment
    */
    Auto: 'auto'
};
/**
 * * `operator` - operator * `course` - course * `program` - program
 * @export
 * @enum {string}
 */
export const NodeTypeEnum = {
    /**
    * operator
    */
    Operator: 'operator',
    /**
    * course
    */
    Course: 'course',
    /**
    * program
    */
    Program: 'program'
};
/**
 *
 * @export
 * @enum {string}
 */
export const NullEnum = {
    Null: 'null'
};
/**
 * * `marketing` - marketing * `sales` - sales * `financial-assistance` - financial-assistance * `customer-support` - customer-support * `staff` - staff * `legacy` - legacy
 * @export
 * @enum {string}
 */
export const PaymentTypeEnum = {
    /**
    * marketing
    */
    Marketing: 'marketing',
    /**
    * sales
    */
    Sales: 'sales',
    /**
    * financial-assistance
    */
    FinancialAssistance: 'financial-assistance',
    /**
    * customer-support
    */
    CustomerSupport: 'customer-support',
    /**
    * staff
    */
    Staff: 'staff',
    /**
    * legacy
    */
    Legacy: 'legacy'
};
/**
 * * `one-time` - one-time * `one-time-per-user` - one-time-per-user * `unlimited` - unlimited
 * @export
 * @enum {string}
 */
export const RedemptionTypeEnum = {
    /**
    * one-time
    */
    OneTime: 'one-time',
    /**
    * one-time-per-user
    */
    OneTimePerUser: 'one-time-per-user',
    /**
    * unlimited
    */
    Unlimited: 'unlimited'
};
/**
 * * `b2b-disallowed` - b2b-disallowed * `b2b-error-no-contract` - b2b-error-no-contract * `b2b-error-no-product` - b2b-error-no-product * `b2b-error-missing-enrollment-code` - b2b-error-missing-enrollment-code * `b2b-error-invalid-enrollment-code` - b2b-error-invalid-enrollment-code * `b2b-error-requires-checkout` - b2b-error-requires-checkout * `b2b-error-not-enrollable` - b2b-error-not-enrollable * `b2b-enroll-success` - b2b-enroll-success
 * @export
 * @enum {string}
 */
export const ResultEnum = {
    /**
    * b2b-disallowed
    */
    Disallowed: 'b2b-disallowed',
    /**
    * b2b-error-no-contract
    */
    ErrorNoContract: 'b2b-error-no-contract',
    /**
    * b2b-error-no-product
    */
    ErrorNoProduct: 'b2b-error-no-product',
    /**
    * b2b-error-missing-enrollment-code
    */
    ErrorMissingEnrollmentCode: 'b2b-error-missing-enrollment-code',
    /**
    * b2b-error-invalid-enrollment-code
    */
    ErrorInvalidEnrollmentCode: 'b2b-error-invalid-enrollment-code',
    /**
    * b2b-error-requires-checkout
    */
    ErrorRequiresCheckout: 'b2b-error-requires-checkout',
    /**
    * b2b-error-not-enrollable
    */
    ErrorNotEnrollable: 'b2b-error-not-enrollable',
    /**
    * b2b-enroll-success
    */
    EnrollSuccess: 'b2b-enroll-success'
};
/**
 * * `pending` - Pending * `fulfilled` - Fulfilled * `canceled` - Canceled * `declined` - Declined * `errored` - Errored * `refunded` - Refunded * `review` - Review * `partially_refunded` - Partially Refunded
 * @export
 * @enum {string}
 */
export const StateEnum = {
    /**
    * Pending
    */
    Pending: 'pending',
    /**
    * Fulfilled
    */
    Fulfilled: 'fulfilled',
    /**
    * Canceled
    */
    Canceled: 'canceled',
    /**
    * Declined
    */
    Declined: 'declined',
    /**
    * Errored
    */
    Errored: 'errored',
    /**
    * Refunded
    */
    Refunded: 'refunded',
    /**
    * Review
    */
    Review: 'review',
    /**
    * Partially Refunded
    */
    PartiallyRefunded: 'partially_refunded'
};
/**
 * * `None` - ---- * `2` - Less than 2 years * `5` - 2-5 years * `10` - 6 - 10 years * `15` - 11 - 15 years * `20` - 16 - 20 years * `21` - More than 20 years * `0` - Prefer not to say
 * @export
 * @enum {string}
 */
export const YearsExperienceEnum = {
    /**
    * Less than 2 years
    */
    NUMBER_2: 2,
    /**
    * 2-5 years
    */
    NUMBER_5: 5,
    /**
    * 6 - 10 years
    */
    NUMBER_10: 10,
    /**
    * 11 - 15 years
    */
    NUMBER_15: 15,
    /**
    * 16 - 20 years
    */
    NUMBER_20: 20,
    /**
    * More than 20 years
    */
    NUMBER_21: 21,
    /**
    * Prefer not to say
    */
    NUMBER_0: 0
};
/**
 * ApiApi - axios parameter creator
 * @export
 */
export const ApiApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Disables sharing links for the learner\'s record. This only applies to the anonymous ones; shares sent to partner schools are always allowed once they are sent.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecordsProgramRevokeCreate: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecordsProgramRevokeCreate', 'id', id);
            const localVarPath = `/api/records/program/{id}/revoke/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sets up a sharing link for the learner\'s record. Returns back the entire learner record.
         * @param {number} id
         * @param {PartnerSchoolRequest} PartnerSchoolRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecordsProgramShareCreate: (id_1, PartnerSchoolRequest_1, ...args_1) => __awaiter(this, [id_1, PartnerSchoolRequest_1, ...args_1], void 0, function* (id, PartnerSchoolRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiRecordsProgramShareCreate', 'id', id);
            // verify required parameter 'PartnerSchoolRequest' is not null or undefined
            assertParamExists('apiRecordsProgramShareCreate', 'PartnerSchoolRequest', PartnerSchoolRequest);
            const localVarPath = `/api/records/program/{id}/share/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(PartnerSchoolRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get learner record using program ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        learnerRecordRetrieveById: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('learnerRecordRetrieveById', 'id', id);
            const localVarPath = `/api/records/program/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get learner record using share UUID
         * @param {string} uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        learnerRecordRetrieveByUuid: (uuid_1, ...args_1) => __awaiter(this, [uuid_1, ...args_1], void 0, function* (uuid, options = {}) {
            // verify required parameter 'uuid' is not null or undefined
            assertParamExists('learnerRecordRetrieveByUuid', 'uuid', uuid);
            const localVarPath = `/api/records/shared/{uuid}/`
                .replace(`{${"uuid"}}`, encodeURIComponent(String(uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ApiApi - functional programming interface
 * @export
 */
export const ApiApiFp = function (configuration) {
    const localVarAxiosParamCreator = ApiApiAxiosParamCreator(configuration);
    return {
        /**
         * Disables sharing links for the learner\'s record. This only applies to the anonymous ones; shares sent to partner schools are always allowed once they are sent.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecordsProgramRevokeCreate(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.apiRecordsProgramRevokeCreate(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ApiApi.apiRecordsProgramRevokeCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Sets up a sharing link for the learner\'s record. Returns back the entire learner record.
         * @param {number} id
         * @param {PartnerSchoolRequest} PartnerSchoolRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecordsProgramShareCreate(id, PartnerSchoolRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.apiRecordsProgramShareCreate(id, PartnerSchoolRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ApiApi.apiRecordsProgramShareCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Get learner record using program ID
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        learnerRecordRetrieveById(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.learnerRecordRetrieveById(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ApiApi.learnerRecordRetrieveById']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Get learner record using share UUID
         * @param {string} uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        learnerRecordRetrieveByUuid(uuid, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.learnerRecordRetrieveByUuid(uuid, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ApiApi.learnerRecordRetrieveByUuid']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * ApiApi - factory interface
 * @export
 */
export const ApiApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ApiApiFp(configuration);
    return {
        /**
         * Disables sharing links for the learner\'s record. This only applies to the anonymous ones; shares sent to partner schools are always allowed once they are sent.
         * @param {ApiApiApiRecordsProgramRevokeCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecordsProgramRevokeCreate(requestParameters, options) {
            return localVarFp.apiRecordsProgramRevokeCreate(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets up a sharing link for the learner\'s record. Returns back the entire learner record.
         * @param {ApiApiApiRecordsProgramShareCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiRecordsProgramShareCreate(requestParameters, options) {
            return localVarFp.apiRecordsProgramShareCreate(requestParameters.id, requestParameters.PartnerSchoolRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get learner record using program ID
         * @param {ApiApiLearnerRecordRetrieveByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        learnerRecordRetrieveById(requestParameters, options) {
            return localVarFp.learnerRecordRetrieveById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get learner record using share UUID
         * @param {ApiApiLearnerRecordRetrieveByUuidRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        learnerRecordRetrieveByUuid(requestParameters, options) {
            return localVarFp.learnerRecordRetrieveByUuid(requestParameters.uuid, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ApiApi - object-oriented interface
 * @export
 * @class ApiApi
 * @extends {BaseAPI}
 */
export class ApiApi extends BaseAPI {
    /**
     * Disables sharing links for the learner\'s record. This only applies to the anonymous ones; shares sent to partner schools are always allowed once they are sent.
     * @param {ApiApiApiRecordsProgramRevokeCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    apiRecordsProgramRevokeCreate(requestParameters, options) {
        return ApiApiFp(this.configuration).apiRecordsProgramRevokeCreate(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sets up a sharing link for the learner\'s record. Returns back the entire learner record.
     * @param {ApiApiApiRecordsProgramShareCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    apiRecordsProgramShareCreate(requestParameters, options) {
        return ApiApiFp(this.configuration).apiRecordsProgramShareCreate(requestParameters.id, requestParameters.PartnerSchoolRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get learner record using program ID
     * @param {ApiApiLearnerRecordRetrieveByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    learnerRecordRetrieveById(requestParameters, options) {
        return ApiApiFp(this.configuration).learnerRecordRetrieveById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get learner record using share UUID
     * @param {ApiApiLearnerRecordRetrieveByUuidRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ApiApi
     */
    learnerRecordRetrieveByUuid(requestParameters, options) {
        return ApiApiFp(this.configuration).learnerRecordRetrieveByUuid(requestParameters.uuid, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * B2bApi - axios parameter creator
 * @export
 */
export const B2bApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Use the provided enrollment code to attach the user to a B2B contract.  This will not create an order, nor will it enroll the user. It will attach the user to the contract and log that the code was used for this purpose (but will _not_ invalidate the code, since we\'re not actually using it at this point).  This will respect the activation and expiration dates (of both the contract and the discount), and will make sure there\'s sufficient available seats in the contract. It will also make sure the code hasn\'t been used for attachment purposes before.  If the user is already in the contract, then we skip it.  Returns: - 201: Code successfully redeemed and user attached to new contract(s) - 200: Code valid but user already attached to all associated contracts - 404: Invalid or expired enrollment code - list of ContractPageSerializer - the contracts for the user
         * @param {string} enrollment_code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bAttachCreate: (enrollment_code_1, ...args_1) => __awaiter(this, [enrollment_code_1, ...args_1], void 0, function* (enrollment_code, options = {}) {
            // verify required parameter 'enrollment_code' is not null or undefined
            assertParamExists('b2bAttachCreate', 'enrollment_code', enrollment_code);
            const localVarPath = `/api/v0/b2b/attach/{enrollment_code}/`
                .replace(`{${"enrollment_code"}}`, encodeURIComponent(String(enrollment_code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Viewset for the ContractPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bContractsList: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v0/b2b/contracts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Viewset for the ContractPage model.
         * @param {string} contract_slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bContractsRetrieve: (contract_slug_1, ...args_1) => __awaiter(this, [contract_slug_1, ...args_1], void 0, function* (contract_slug, options = {}) {
            // verify required parameter 'contract_slug' is not null or undefined
            assertParamExists('b2bContractsRetrieve', 'contract_slug', contract_slug);
            const localVarPath = `/api/v0/b2b/contracts/{contract_slug}/`
                .replace(`{${"contract_slug"}}`, encodeURIComponent(String(contract_slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create an enrollment for the given course run.
         * @param {string} readable_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bEnrollCreate: (readable_id_1, ...args_1) => __awaiter(this, [readable_id_1, ...args_1], void 0, function* (readable_id, options = {}) {
            // verify required parameter 'readable_id' is not null or undefined
            assertParamExists('b2bEnrollCreate', 'readable_id', readable_id);
            const localVarPath = `/api/v0/b2b/enroll/{readable_id}/`
                .replace(`{${"readable_id"}}`, encodeURIComponent(String(readable_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Viewset for the OrganizationPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bOrganizationsList: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v0/b2b/organizations/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Viewset for the OrganizationPage model.
         * @param {string} organization_slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bOrganizationsRetrieve: (organization_slug_1, ...args_1) => __awaiter(this, [organization_slug_1, ...args_1], void 0, function* (organization_slug, options = {}) {
            // verify required parameter 'organization_slug' is not null or undefined
            assertParamExists('b2bOrganizationsRetrieve', 'organization_slug', organization_slug);
            const localVarPath = `/api/v0/b2b/organizations/{organization_slug}/`
                .replace(`{${"organization_slug"}}`, encodeURIComponent(String(organization_slug)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * B2bApi - functional programming interface
 * @export
 */
export const B2bApiFp = function (configuration) {
    const localVarAxiosParamCreator = B2bApiAxiosParamCreator(configuration);
    return {
        /**
         * Use the provided enrollment code to attach the user to a B2B contract.  This will not create an order, nor will it enroll the user. It will attach the user to the contract and log that the code was used for this purpose (but will _not_ invalidate the code, since we\'re not actually using it at this point).  This will respect the activation and expiration dates (of both the contract and the discount), and will make sure there\'s sufficient available seats in the contract. It will also make sure the code hasn\'t been used for attachment purposes before.  If the user is already in the contract, then we skip it.  Returns: - 201: Code successfully redeemed and user attached to new contract(s) - 200: Code valid but user already attached to all associated contracts - 404: Invalid or expired enrollment code - list of ContractPageSerializer - the contracts for the user
         * @param {string} enrollment_code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bAttachCreate(enrollment_code, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.b2bAttachCreate(enrollment_code, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['B2bApi.b2bAttachCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Viewset for the ContractPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bContractsList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.b2bContractsList(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['B2bApi.b2bContractsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Viewset for the ContractPage model.
         * @param {string} contract_slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bContractsRetrieve(contract_slug, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.b2bContractsRetrieve(contract_slug, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['B2bApi.b2bContractsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Create an enrollment for the given course run.
         * @param {string} readable_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bEnrollCreate(readable_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.b2bEnrollCreate(readable_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['B2bApi.b2bEnrollCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Viewset for the OrganizationPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bOrganizationsList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.b2bOrganizationsList(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['B2bApi.b2bOrganizationsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Viewset for the OrganizationPage model.
         * @param {string} organization_slug
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bOrganizationsRetrieve(organization_slug, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.b2bOrganizationsRetrieve(organization_slug, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['B2bApi.b2bOrganizationsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * B2bApi - factory interface
 * @export
 */
export const B2bApiFactory = function (configuration, basePath, axios) {
    const localVarFp = B2bApiFp(configuration);
    return {
        /**
         * Use the provided enrollment code to attach the user to a B2B contract.  This will not create an order, nor will it enroll the user. It will attach the user to the contract and log that the code was used for this purpose (but will _not_ invalidate the code, since we\'re not actually using it at this point).  This will respect the activation and expiration dates (of both the contract and the discount), and will make sure there\'s sufficient available seats in the contract. It will also make sure the code hasn\'t been used for attachment purposes before.  If the user is already in the contract, then we skip it.  Returns: - 201: Code successfully redeemed and user attached to new contract(s) - 200: Code valid but user already attached to all associated contracts - 404: Invalid or expired enrollment code - list of ContractPageSerializer - the contracts for the user
         * @param {B2bApiB2bAttachCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bAttachCreate(requestParameters, options) {
            return localVarFp.b2bAttachCreate(requestParameters.enrollment_code, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for the ContractPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bContractsList(options) {
            return localVarFp.b2bContractsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for the ContractPage model.
         * @param {B2bApiB2bContractsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bContractsRetrieve(requestParameters, options) {
            return localVarFp.b2bContractsRetrieve(requestParameters.contract_slug, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an enrollment for the given course run.
         * @param {B2bApiB2bEnrollCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bEnrollCreate(requestParameters, options) {
            return localVarFp.b2bEnrollCreate(requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for the OrganizationPage model.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bOrganizationsList(options) {
            return localVarFp.b2bOrganizationsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for the OrganizationPage model.
         * @param {B2bApiB2bOrganizationsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        b2bOrganizationsRetrieve(requestParameters, options) {
            return localVarFp.b2bOrganizationsRetrieve(requestParameters.organization_slug, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * B2bApi - object-oriented interface
 * @export
 * @class B2bApi
 * @extends {BaseAPI}
 */
export class B2bApi extends BaseAPI {
    /**
     * Use the provided enrollment code to attach the user to a B2B contract.  This will not create an order, nor will it enroll the user. It will attach the user to the contract and log that the code was used for this purpose (but will _not_ invalidate the code, since we\'re not actually using it at this point).  This will respect the activation and expiration dates (of both the contract and the discount), and will make sure there\'s sufficient available seats in the contract. It will also make sure the code hasn\'t been used for attachment purposes before.  If the user is already in the contract, then we skip it.  Returns: - 201: Code successfully redeemed and user attached to new contract(s) - 200: Code valid but user already attached to all associated contracts - 404: Invalid or expired enrollment code - list of ContractPageSerializer - the contracts for the user
     * @param {B2bApiB2bAttachCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    b2bAttachCreate(requestParameters, options) {
        return B2bApiFp(this.configuration).b2bAttachCreate(requestParameters.enrollment_code, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Viewset for the ContractPage model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    b2bContractsList(options) {
        return B2bApiFp(this.configuration).b2bContractsList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Viewset for the ContractPage model.
     * @param {B2bApiB2bContractsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    b2bContractsRetrieve(requestParameters, options) {
        return B2bApiFp(this.configuration).b2bContractsRetrieve(requestParameters.contract_slug, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create an enrollment for the given course run.
     * @param {B2bApiB2bEnrollCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    b2bEnrollCreate(requestParameters, options) {
        return B2bApiFp(this.configuration).b2bEnrollCreate(requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Viewset for the OrganizationPage model.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    b2bOrganizationsList(options) {
        return B2bApiFp(this.configuration).b2bOrganizationsList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Viewset for the OrganizationPage model.
     * @param {B2bApiB2bOrganizationsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof B2bApi
     */
    b2bOrganizationsRetrieve(requestParameters, options) {
        return B2bApiFp(this.configuration).b2bOrganizationsRetrieve(requestParameters.organization_slug, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BasketsApi - axios parameter creator
 * @export
 */
export const BasketsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Creates or updates a basket for the current user, adding the discount if valid.
         * @param {string} discount_code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsAddDiscountCreate: (discount_code_1, ...args_1) => __awaiter(this, [discount_code_1, ...args_1], void 0, function* (discount_code, options = {}) {
            // verify required parameter 'discount_code' is not null or undefined
            assertParamExists('basketsAddDiscountCreate', 'discount_code', discount_code);
            const localVarPath = `/api/v0/baskets/add_discount/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (discount_code !== undefined) {
                localVarQueryParameter['discount_code'] = discount_code;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the payload necessary to redirect the user to CyberSource for payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCheckoutRetrieve: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v0/baskets/checkout/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Clears the basket for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsClearDestroy: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v0/baskets/clear/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {number} product_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCreateFromProductCreate: (product_id_1, ...args_1) => __awaiter(this, [product_id_1, ...args_1], void 0, function* (product_id, options = {}) {
            // verify required parameter 'product_id' is not null or undefined
            assertParamExists('basketsCreateFromProductCreate', 'product_id', product_id);
            const localVarPath = `/api/v0/baskets/create_from_product/{product_id}/`
                .replace(`{${"product_id"}}`, encodeURIComponent(String(product_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {CreateBasketWithProductsRequest} CreateBasketWithProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCreateWithProductsCreate: (CreateBasketWithProductsRequest_1, ...args_1) => __awaiter(this, [CreateBasketWithProductsRequest_1, ...args_1], void 0, function* (CreateBasketWithProductsRequest, options = {}) {
            // verify required parameter 'CreateBasketWithProductsRequest' is not null or undefined
            assertParamExists('basketsCreateWithProductsCreate', 'CreateBasketWithProductsRequest', CreateBasketWithProductsRequest);
            const localVarPath = `/api/v0/baskets/create_with_products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(CreateBasketWithProductsRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsCreate: (id_1, parent_lookup_basket_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_basket_1, ...args_1], void 0, function* (id, parent_lookup_basket, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsCreate', 'id', id);
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsCreate', 'parent_lookup_basket', parent_lookup_basket);
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsDestroy: (id_1, parent_lookup_basket_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_basket_1, ...args_1], void 0, function* (id, parent_lookup_basket, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsDestroy', 'id', id);
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsDestroy', 'parent_lookup_basket', parent_lookup_basket);
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsList: (id_1, parent_lookup_basket_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_basket_1, ...args_1], void 0, function* (id, parent_lookup_basket, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsList', 'id', id);
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsList', 'parent_lookup_basket', parent_lookup_basket);
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsPartialUpdate: (id_1, parent_lookup_basket_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_basket_1, ...args_1], void 0, function* (id, parent_lookup_basket, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsPartialUpdate', 'id', id);
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsPartialUpdate', 'parent_lookup_basket', parent_lookup_basket);
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsRetrieve: (id_1, parent_lookup_basket_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_basket_1, ...args_1], void 0, function* (id, parent_lookup_basket, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsRetrieve', 'id', id);
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsRetrieve', 'parent_lookup_basket', parent_lookup_basket);
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsUpdate: (id_1, parent_lookup_basket_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_basket_1, ...args_1], void 0, function* (id, parent_lookup_basket, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsItemsUpdate', 'id', id);
            // verify required parameter 'parent_lookup_basket' is not null or undefined
            assertParamExists('basketsItemsUpdate', 'parent_lookup_basket', parent_lookup_basket);
            const localVarPath = `/api/v0/baskets/{parent_lookup_basket}/items/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_basket"}}`, encodeURIComponent(String(parent_lookup_basket)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrives the current user\'s baskets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsList: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v0/baskets/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a basket for the current user.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('basketsRetrieve', 'id', id);
            const localVarPath = `/api/v0/baskets/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Creates or updates a basket for the current user, adding the selected product and discount.
         * @param {string} discount_code
         * @param {number} product_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBasketFromProductWithDiscount: (discount_code_1, product_id_1, ...args_1) => __awaiter(this, [discount_code_1, product_id_1, ...args_1], void 0, function* (discount_code, product_id, options = {}) {
            // verify required parameter 'discount_code' is not null or undefined
            assertParamExists('createBasketFromProductWithDiscount', 'discount_code', discount_code);
            // verify required parameter 'product_id' is not null or undefined
            assertParamExists('createBasketFromProductWithDiscount', 'product_id', product_id);
            const localVarPath = `/api/v0/baskets/create_from_product/{product_id}/{discount_code}/`
                .replace(`{${"discount_code"}}`, encodeURIComponent(String(discount_code)))
                .replace(`{${"product_id"}}`, encodeURIComponent(String(product_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * BasketsApi - functional programming interface
 * @export
 */
export const BasketsApiFp = function (configuration) {
    const localVarAxiosParamCreator = BasketsApiAxiosParamCreator(configuration);
    return {
        /**
         * Creates or updates a basket for the current user, adding the discount if valid.
         * @param {string} discount_code
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsAddDiscountCreate(discount_code, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsAddDiscountCreate(discount_code, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsAddDiscountCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns the payload necessary to redirect the user to CyberSource for payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCheckoutRetrieve(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsCheckoutRetrieve(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsCheckoutRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Clears the basket for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsClearDestroy(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsClearDestroy(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsClearDestroy']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {number} product_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCreateFromProductCreate(product_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsCreateFromProductCreate(product_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsCreateFromProductCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {CreateBasketWithProductsRequest} CreateBasketWithProductsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCreateWithProductsCreate(CreateBasketWithProductsRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsCreateWithProductsCreate(CreateBasketWithProductsRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsCreateWithProductsCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsCreate(id, parent_lookup_basket, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsItemsCreate(id, parent_lookup_basket, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsItemsCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsDestroy(id, parent_lookup_basket, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsItemsDestroy(id, parent_lookup_basket, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsItemsDestroy']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsList(id, parent_lookup_basket, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsItemsList(id, parent_lookup_basket, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsItemsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsPartialUpdate(id, parent_lookup_basket, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsItemsPartialUpdate(id, parent_lookup_basket, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsItemsPartialUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsRetrieve(id, parent_lookup_basket, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsItemsRetrieve(id, parent_lookup_basket, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsItemsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns the basket items for the current user.
         * @param {number} id ID of the basket item
         * @param {number} parent_lookup_basket ID of the parent basket
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsUpdate(id, parent_lookup_basket, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsItemsUpdate(id, parent_lookup_basket, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsItemsUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Retrives the current user\'s baskets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsList(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Retrieve a basket for the current user.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.basketsRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.basketsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product and discount.
         * @param {string} discount_code
         * @param {number} product_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBasketFromProductWithDiscount(discount_code, product_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.createBasketFromProductWithDiscount(discount_code, product_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['BasketsApi.createBasketFromProductWithDiscount']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * BasketsApi - factory interface
 * @export
 */
export const BasketsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BasketsApiFp(configuration);
    return {
        /**
         * Creates or updates a basket for the current user, adding the discount if valid.
         * @param {BasketsApiBasketsAddDiscountCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsAddDiscountCreate(requestParameters, options) {
            return localVarFp.basketsAddDiscountCreate(requestParameters.discount_code, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the payload necessary to redirect the user to CyberSource for payment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCheckoutRetrieve(options) {
            return localVarFp.basketsCheckoutRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Clears the basket for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsClearDestroy(options) {
            return localVarFp.basketsClearDestroy(options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {BasketsApiBasketsCreateFromProductCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCreateFromProductCreate(requestParameters, options) {
            return localVarFp.basketsCreateFromProductCreate(requestParameters.product_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product.
         * @param {BasketsApiBasketsCreateWithProductsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsCreateWithProductsCreate(requestParameters, options) {
            return localVarFp.basketsCreateWithProductsCreate(requestParameters.CreateBasketWithProductsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsCreate(requestParameters, options) {
            return localVarFp.basketsItemsCreate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsDestroy(requestParameters, options) {
            return localVarFp.basketsItemsDestroy(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsList(requestParameters, options) {
            return localVarFp.basketsItemsList(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsPartialUpdate(requestParameters, options) {
            return localVarFp.basketsItemsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsRetrieve(requestParameters, options) {
            return localVarFp.basketsItemsRetrieve(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the basket items for the current user.
         * @param {BasketsApiBasketsItemsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsItemsUpdate(requestParameters, options) {
            return localVarFp.basketsItemsUpdate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrives the current user\'s baskets.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsList(options) {
            return localVarFp.basketsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a basket for the current user.
         * @param {BasketsApiBasketsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        basketsRetrieve(requestParameters, options) {
            return localVarFp.basketsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates or updates a basket for the current user, adding the selected product and discount.
         * @param {BasketsApiCreateBasketFromProductWithDiscountRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createBasketFromProductWithDiscount(requestParameters, options) {
            return localVarFp.createBasketFromProductWithDiscount(requestParameters.discount_code, requestParameters.product_id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BasketsApi - object-oriented interface
 * @export
 * @class BasketsApi
 * @extends {BaseAPI}
 */
export class BasketsApi extends BaseAPI {
    /**
     * Creates or updates a basket for the current user, adding the discount if valid.
     * @param {BasketsApiBasketsAddDiscountCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsAddDiscountCreate(requestParameters, options) {
        return BasketsApiFp(this.configuration).basketsAddDiscountCreate(requestParameters.discount_code, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the payload necessary to redirect the user to CyberSource for payment.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsCheckoutRetrieve(options) {
        return BasketsApiFp(this.configuration).basketsCheckoutRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Clears the basket for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsClearDestroy(options) {
        return BasketsApiFp(this.configuration).basketsClearDestroy(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates or updates a basket for the current user, adding the selected product.
     * @param {BasketsApiBasketsCreateFromProductCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsCreateFromProductCreate(requestParameters, options) {
        return BasketsApiFp(this.configuration).basketsCreateFromProductCreate(requestParameters.product_id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates or updates a basket for the current user, adding the selected product.
     * @param {BasketsApiBasketsCreateWithProductsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsCreateWithProductsCreate(requestParameters, options) {
        return BasketsApiFp(this.configuration).basketsCreateWithProductsCreate(requestParameters.CreateBasketWithProductsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsItemsCreate(requestParameters, options) {
        return BasketsApiFp(this.configuration).basketsItemsCreate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsItemsDestroy(requestParameters, options) {
        return BasketsApiFp(this.configuration).basketsItemsDestroy(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsItemsList(requestParameters, options) {
        return BasketsApiFp(this.configuration).basketsItemsList(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsItemsPartialUpdate(requestParameters, options) {
        return BasketsApiFp(this.configuration).basketsItemsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsItemsRetrieve(requestParameters, options) {
        return BasketsApiFp(this.configuration).basketsItemsRetrieve(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the basket items for the current user.
     * @param {BasketsApiBasketsItemsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsItemsUpdate(requestParameters, options) {
        return BasketsApiFp(this.configuration).basketsItemsUpdate(requestParameters.id, requestParameters.parent_lookup_basket, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrives the current user\'s baskets.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsList(options) {
        return BasketsApiFp(this.configuration).basketsList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a basket for the current user.
     * @param {BasketsApiBasketsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    basketsRetrieve(requestParameters, options) {
        return BasketsApiFp(this.configuration).basketsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates or updates a basket for the current user, adding the selected product and discount.
     * @param {BasketsApiCreateBasketFromProductWithDiscountRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BasketsApi
     */
    createBasketFromProductWithDiscount(requestParameters, options) {
        return BasketsApiFp(this.configuration).createBasketFromProductWithDiscount(requestParameters.discount_code, requestParameters.product_id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ChangeEmailsApi - axios parameter creator
 * @export
 */
export const ChangeEmailsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Viewset for creating and updating email change requests
         * @param {ChangeEmailRequestCreateRequest} ChangeEmailRequestCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsCreate: (ChangeEmailRequestCreateRequest_1, ...args_1) => __awaiter(this, [ChangeEmailRequestCreateRequest_1, ...args_1], void 0, function* (ChangeEmailRequestCreateRequest, options = {}) {
            // verify required parameter 'ChangeEmailRequestCreateRequest' is not null or undefined
            assertParamExists('changeEmailsCreate', 'ChangeEmailRequestCreateRequest', ChangeEmailRequestCreateRequest);
            const localVarPath = `/api/v0/change-emails/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(ChangeEmailRequestCreateRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Viewset for creating and updating email change requests
         * @param {string} code
         * @param {PatchedChangeEmailRequestUpdateRequest} [PatchedChangeEmailRequestUpdateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsPartialUpdate: (code_1, PatchedChangeEmailRequestUpdateRequest_1, ...args_1) => __awaiter(this, [code_1, PatchedChangeEmailRequestUpdateRequest_1, ...args_1], void 0, function* (code, PatchedChangeEmailRequestUpdateRequest, options = {}) {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('changeEmailsPartialUpdate', 'code', code);
            const localVarPath = `/api/v0/change-emails/{code}/`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedChangeEmailRequestUpdateRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Viewset for creating and updating email change requests
         * @param {string} code
         * @param {ChangeEmailRequestUpdateRequest} ChangeEmailRequestUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsUpdate: (code_1, ChangeEmailRequestUpdateRequest_1, ...args_1) => __awaiter(this, [code_1, ChangeEmailRequestUpdateRequest_1, ...args_1], void 0, function* (code, ChangeEmailRequestUpdateRequest, options = {}) {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('changeEmailsUpdate', 'code', code);
            // verify required parameter 'ChangeEmailRequestUpdateRequest' is not null or undefined
            assertParamExists('changeEmailsUpdate', 'ChangeEmailRequestUpdateRequest', ChangeEmailRequestUpdateRequest);
            const localVarPath = `/api/v0/change-emails/{code}/`
                .replace(`{${"code"}}`, encodeURIComponent(String(code)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(ChangeEmailRequestUpdateRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ChangeEmailsApi - functional programming interface
 * @export
 */
export const ChangeEmailsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ChangeEmailsApiAxiosParamCreator(configuration);
    return {
        /**
         * Viewset for creating and updating email change requests
         * @param {ChangeEmailRequestCreateRequest} ChangeEmailRequestCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsCreate(ChangeEmailRequestCreateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changeEmailsCreate(ChangeEmailRequestCreateRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ChangeEmailsApi.changeEmailsCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Viewset for creating and updating email change requests
         * @param {string} code
         * @param {PatchedChangeEmailRequestUpdateRequest} [PatchedChangeEmailRequestUpdateRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsPartialUpdate(code, PatchedChangeEmailRequestUpdateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changeEmailsPartialUpdate(code, PatchedChangeEmailRequestUpdateRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ChangeEmailsApi.changeEmailsPartialUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Viewset for creating and updating email change requests
         * @param {string} code
         * @param {ChangeEmailRequestUpdateRequest} ChangeEmailRequestUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsUpdate(code, ChangeEmailRequestUpdateRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.changeEmailsUpdate(code, ChangeEmailRequestUpdateRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ChangeEmailsApi.changeEmailsUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * ChangeEmailsApi - factory interface
 * @export
 */
export const ChangeEmailsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ChangeEmailsApiFp(configuration);
    return {
        /**
         * Viewset for creating and updating email change requests
         * @param {ChangeEmailsApiChangeEmailsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsCreate(requestParameters, options) {
            return localVarFp.changeEmailsCreate(requestParameters.ChangeEmailRequestCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for creating and updating email change requests
         * @param {ChangeEmailsApiChangeEmailsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsPartialUpdate(requestParameters, options) {
            return localVarFp.changeEmailsPartialUpdate(requestParameters.code, requestParameters.PatchedChangeEmailRequestUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset for creating and updating email change requests
         * @param {ChangeEmailsApiChangeEmailsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        changeEmailsUpdate(requestParameters, options) {
            return localVarFp.changeEmailsUpdate(requestParameters.code, requestParameters.ChangeEmailRequestUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ChangeEmailsApi - object-oriented interface
 * @export
 * @class ChangeEmailsApi
 * @extends {BaseAPI}
 */
export class ChangeEmailsApi extends BaseAPI {
    /**
     * Viewset for creating and updating email change requests
     * @param {ChangeEmailsApiChangeEmailsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeEmailsApi
     */
    changeEmailsCreate(requestParameters, options) {
        return ChangeEmailsApiFp(this.configuration).changeEmailsCreate(requestParameters.ChangeEmailRequestCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Viewset for creating and updating email change requests
     * @param {ChangeEmailsApiChangeEmailsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeEmailsApi
     */
    changeEmailsPartialUpdate(requestParameters, options) {
        return ChangeEmailsApiFp(this.configuration).changeEmailsPartialUpdate(requestParameters.code, requestParameters.PatchedChangeEmailRequestUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Viewset for creating and updating email change requests
     * @param {ChangeEmailsApiChangeEmailsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChangeEmailsApi
     */
    changeEmailsUpdate(requestParameters, options) {
        return ChangeEmailsApiFp(this.configuration).changeEmailsUpdate(requestParameters.code, requestParameters.ChangeEmailRequestUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CountriesApi - axios parameter creator
 * @export
 */
export const CountriesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get generator for countries/states list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesList: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v0/countries/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CountriesApi - functional programming interface
 * @export
 */
export const CountriesApiFp = function (configuration) {
    const localVarAxiosParamCreator = CountriesApiAxiosParamCreator(configuration);
    return {
        /**
         * Get generator for countries/states list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.countriesList(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['CountriesApi.countriesList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * CountriesApi - factory interface
 * @export
 */
export const CountriesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CountriesApiFp(configuration);
    return {
        /**
         * Get generator for countries/states list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countriesList(options) {
            return localVarFp.countriesList(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CountriesApi - object-oriented interface
 * @export
 * @class CountriesApi
 * @extends {BaseAPI}
 */
export class CountriesApi extends BaseAPI {
    /**
     * Get generator for countries/states list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CountriesApi
     */
    countriesList(options) {
        return CountriesApiFp(this.configuration).countriesList(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CourseCertificatesApi - axios parameter creator
 * @export
 */
export const CourseCertificatesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a course certificate by UUID.
         * @param {string} cert_uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseCertificatesRetrieve: (cert_uuid_1, ...args_1) => __awaiter(this, [cert_uuid_1, ...args_1], void 0, function* (cert_uuid, options = {}) {
            // verify required parameter 'cert_uuid' is not null or undefined
            assertParamExists('courseCertificatesRetrieve', 'cert_uuid', cert_uuid);
            const localVarPath = `/api/v2/course_certificates/{cert_uuid}/`
                .replace(`{${"cert_uuid"}}`, encodeURIComponent(String(cert_uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CourseCertificatesApi - functional programming interface
 * @export
 */
export const CourseCertificatesApiFp = function (configuration) {
    const localVarAxiosParamCreator = CourseCertificatesApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a course certificate by UUID.
         * @param {string} cert_uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseCertificatesRetrieve(cert_uuid, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.courseCertificatesRetrieve(cert_uuid, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['CourseCertificatesApi.courseCertificatesRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * CourseCertificatesApi - factory interface
 * @export
 */
export const CourseCertificatesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CourseCertificatesApiFp(configuration);
    return {
        /**
         * Get a course certificate by UUID.
         * @param {CourseCertificatesApiCourseCertificatesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseCertificatesRetrieve(requestParameters, options) {
            return localVarFp.courseCertificatesRetrieve(requestParameters.cert_uuid, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CourseCertificatesApi - object-oriented interface
 * @export
 * @class CourseCertificatesApi
 * @extends {BaseAPI}
 */
export class CourseCertificatesApi extends BaseAPI {
    /**
     * Get a course certificate by UUID.
     * @param {CourseCertificatesApiCourseCertificatesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseCertificatesApi
     */
    courseCertificatesRetrieve(requestParameters, options) {
        return CourseCertificatesApiFp(this.configuration).courseCertificatesRetrieve(requestParameters.cert_uuid, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CourseRunsApi - axios parameter creator
 * @export
 */
export const CourseRunsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * API view set for CourseRuns
         * @param {number} [id]
         * @param {boolean} [live]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRunsList: (id_1, live_1, ...args_1) => __awaiter(this, [id_1, live_1, ...args_1], void 0, function* (id, live, options = {}) {
            const localVarPath = `/api/v1/course_runs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (live !== undefined) {
                localVarQueryParameter['live'] = live;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for CourseRuns
         * @param {number} id A unique integer value identifying this course run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRunsRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('courseRunsRetrieve', 'id', id);
            const localVarPath = `/api/v1/course_runs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CourseRunsApi - functional programming interface
 * @export
 */
export const CourseRunsApiFp = function (configuration) {
    const localVarAxiosParamCreator = CourseRunsApiAxiosParamCreator(configuration);
    return {
        /**
         * API view set for CourseRuns
         * @param {number} [id]
         * @param {boolean} [live]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRunsList(id, live, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.courseRunsList(id, live, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['CourseRunsApi.courseRunsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for CourseRuns
         * @param {number} id A unique integer value identifying this course run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRunsRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.courseRunsRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['CourseRunsApi.courseRunsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * CourseRunsApi - factory interface
 * @export
 */
export const CourseRunsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CourseRunsApiFp(configuration);
    return {
        /**
         * API view set for CourseRuns
         * @param {CourseRunsApiCourseRunsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRunsList(requestParameters = {}, options) {
            return localVarFp.courseRunsList(requestParameters.id, requestParameters.live, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for CourseRuns
         * @param {CourseRunsApiCourseRunsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        courseRunsRetrieve(requestParameters, options) {
            return localVarFp.courseRunsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CourseRunsApi - object-oriented interface
 * @export
 * @class CourseRunsApi
 * @extends {BaseAPI}
 */
export class CourseRunsApi extends BaseAPI {
    /**
     * API view set for CourseRuns
     * @param {CourseRunsApiCourseRunsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRunsApi
     */
    courseRunsList(requestParameters = {}, options) {
        return CourseRunsApiFp(this.configuration).courseRunsList(requestParameters.id, requestParameters.live, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for CourseRuns
     * @param {CourseRunsApiCourseRunsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CourseRunsApi
     */
    courseRunsRetrieve(requestParameters, options) {
        return CourseRunsApiFp(this.configuration).courseRunsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * CoursesApi - axios parameter creator
 * @export
 */
export const CoursesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List all courses - API v1
         * @param {boolean} [courserun_is_enrollable]
         * @param {number} [id]
         * @param {boolean} [live]
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live]
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CoursesList: (courserun_is_enrollable_1, id_1, live_1, page_1, page__live_1, page_size_1, readable_id_1, ...args_1) => __awaiter(this, [courserun_is_enrollable_1, id_1, live_1, page_1, page__live_1, page_size_1, readable_id_1, ...args_1], void 0, function* (courserun_is_enrollable, id, live, page, page__live, page_size, readable_id, options = {}) {
            const localVarPath = `/api/v1/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (courserun_is_enrollable !== undefined) {
                localVarQueryParameter['courserun_is_enrollable'] = courserun_is_enrollable;
            }
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (live !== undefined) {
                localVarQueryParameter['live'] = live;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (page__live !== undefined) {
                localVarQueryParameter['page__live'] = page__live;
            }
            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }
            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a specific course - API v1
         * @param {number} id A unique integer value identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CoursesRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV1CoursesRetrieve', 'id', id);
            const localVarPath = `/api/v1/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List all courses - API v2
         * @param {number} [contract_id] Only show courses belonging to this B2B contract
         * @param {boolean} [courserun_is_enrollable] Course Run Is Enrollable
         * @param {Array<number>} [id] Multiple values may be separated by commas.
         * @param {boolean} [include_approved_financial_aid] Include approved financial assistance information
         * @param {boolean} [live]
         * @param {number} [org_id] Only show courses belonging to this B2B/UAI organization
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live]
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2CoursesList: (contract_id_1, courserun_is_enrollable_1, id_1, include_approved_financial_aid_1, live_1, org_id_1, page_1, page__live_1, page_size_1, readable_id_1, ...args_1) => __awaiter(this, [contract_id_1, courserun_is_enrollable_1, id_1, include_approved_financial_aid_1, live_1, org_id_1, page_1, page__live_1, page_size_1, readable_id_1, ...args_1], void 0, function* (contract_id, courserun_is_enrollable, id, include_approved_financial_aid, live, org_id, page, page__live, page_size, readable_id, options = {}) {
            const localVarPath = `/api/v2/courses/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contract_id !== undefined) {
                localVarQueryParameter['contract_id'] = contract_id;
            }
            if (courserun_is_enrollable !== undefined) {
                localVarQueryParameter['courserun_is_enrollable'] = courserun_is_enrollable;
            }
            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }
            if (include_approved_financial_aid !== undefined) {
                localVarQueryParameter['include_approved_financial_aid'] = include_approved_financial_aid;
            }
            if (live !== undefined) {
                localVarQueryParameter['live'] = live;
            }
            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (page__live !== undefined) {
                localVarQueryParameter['page__live'] = page__live;
            }
            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }
            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a specific course - API v2
         * @param {number} id A unique integer value identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2CoursesRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('apiV2CoursesRetrieve', 'id', id);
            const localVarPath = `/api/v2/courses/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * CoursesApi - functional programming interface
 * @export
 */
export const CoursesApiFp = function (configuration) {
    const localVarAxiosParamCreator = CoursesApiAxiosParamCreator(configuration);
    return {
        /**
         * List all courses - API v1
         * @param {boolean} [courserun_is_enrollable]
         * @param {number} [id]
         * @param {boolean} [live]
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live]
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CoursesList(courserun_is_enrollable, id, live, page, page__live, page_size, readable_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.apiV1CoursesList(courserun_is_enrollable, id, live, page, page__live, page_size, readable_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['CoursesApi.apiV1CoursesList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Retrieve a specific course - API v1
         * @param {number} id A unique integer value identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CoursesRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.apiV1CoursesRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['CoursesApi.apiV1CoursesRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * List all courses - API v2
         * @param {number} [contract_id] Only show courses belonging to this B2B contract
         * @param {boolean} [courserun_is_enrollable] Course Run Is Enrollable
         * @param {Array<number>} [id] Multiple values may be separated by commas.
         * @param {boolean} [include_approved_financial_aid] Include approved financial assistance information
         * @param {boolean} [live]
         * @param {number} [org_id] Only show courses belonging to this B2B/UAI organization
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live]
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2CoursesList(contract_id, courserun_is_enrollable, id, include_approved_financial_aid, live, org_id, page, page__live, page_size, readable_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.apiV2CoursesList(contract_id, courserun_is_enrollable, id, include_approved_financial_aid, live, org_id, page, page__live, page_size, readable_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['CoursesApi.apiV2CoursesList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Retrieve a specific course - API v2
         * @param {number} id A unique integer value identifying this course.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2CoursesRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.apiV2CoursesRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['CoursesApi.apiV2CoursesRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * CoursesApi - factory interface
 * @export
 */
export const CoursesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = CoursesApiFp(configuration);
    return {
        /**
         * List all courses - API v1
         * @param {CoursesApiApiV1CoursesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CoursesList(requestParameters = {}, options) {
            return localVarFp.apiV1CoursesList(requestParameters.courserun_is_enrollable, requestParameters.id, requestParameters.live, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific course - API v1
         * @param {CoursesApiApiV1CoursesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CoursesRetrieve(requestParameters, options) {
            return localVarFp.apiV1CoursesRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * List all courses - API v2
         * @param {CoursesApiApiV2CoursesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2CoursesList(requestParameters = {}, options) {
            return localVarFp.apiV2CoursesList(requestParameters.contract_id, requestParameters.courserun_is_enrollable, requestParameters.id, requestParameters.include_approved_financial_aid, requestParameters.live, requestParameters.org_id, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific course - API v2
         * @param {CoursesApiApiV2CoursesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV2CoursesRetrieve(requestParameters, options) {
            return localVarFp.apiV2CoursesRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * CoursesApi - object-oriented interface
 * @export
 * @class CoursesApi
 * @extends {BaseAPI}
 */
export class CoursesApi extends BaseAPI {
    /**
     * List all courses - API v1
     * @param {CoursesApiApiV1CoursesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    apiV1CoursesList(requestParameters = {}, options) {
        return CoursesApiFp(this.configuration).apiV1CoursesList(requestParameters.courserun_is_enrollable, requestParameters.id, requestParameters.live, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a specific course - API v1
     * @param {CoursesApiApiV1CoursesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    apiV1CoursesRetrieve(requestParameters, options) {
        return CoursesApiFp(this.configuration).apiV1CoursesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List all courses - API v2
     * @param {CoursesApiApiV2CoursesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    apiV2CoursesList(requestParameters = {}, options) {
        return CoursesApiFp(this.configuration).apiV2CoursesList(requestParameters.contract_id, requestParameters.courserun_is_enrollable, requestParameters.id, requestParameters.include_approved_financial_aid, requestParameters.live, requestParameters.org_id, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a specific course - API v2
     * @param {CoursesApiApiV2CoursesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CoursesApi
     */
    apiV2CoursesRetrieve(requestParameters, options) {
        return CoursesApiFp(this.configuration).apiV2CoursesRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DepartmentsApi - axios parameter creator
 * @export
 */
export const DepartmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List departments - v1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsListV1: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v1/departments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List departments - v2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsListV2: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v2/departments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get department details - v1
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRetrieveV1: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('departmentsRetrieveV1', 'id', id);
            const localVarPath = `/api/v1/departments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get department details - v2
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRetrieveV2: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('departmentsRetrieveV2', 'id', id);
            const localVarPath = `/api/v2/departments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DepartmentsApi - functional programming interface
 * @export
 */
export const DepartmentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DepartmentsApiAxiosParamCreator(configuration);
    return {
        /**
         * List departments - v1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsListV1(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.departmentsListV1(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DepartmentsApi.departmentsListV1']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * List departments - v2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsListV2(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.departmentsListV2(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DepartmentsApi.departmentsListV2']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Get department details - v1
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRetrieveV1(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.departmentsRetrieveV1(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DepartmentsApi.departmentsRetrieveV1']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Get department details - v2
         * @param {number} id A unique integer value identifying this department.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRetrieveV2(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.departmentsRetrieveV2(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DepartmentsApi.departmentsRetrieveV2']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * DepartmentsApi - factory interface
 * @export
 */
export const DepartmentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DepartmentsApiFp(configuration);
    return {
        /**
         * List departments - v1
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsListV1(options) {
            return localVarFp.departmentsListV1(options).then((request) => request(axios, basePath));
        },
        /**
         * List departments - v2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsListV2(options) {
            return localVarFp.departmentsListV2(options).then((request) => request(axios, basePath));
        },
        /**
         * Get department details - v1
         * @param {DepartmentsApiDepartmentsRetrieveV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRetrieveV1(requestParameters, options) {
            return localVarFp.departmentsRetrieveV1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Get department details - v2
         * @param {DepartmentsApiDepartmentsRetrieveV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        departmentsRetrieveV2(requestParameters, options) {
            return localVarFp.departmentsRetrieveV2(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DepartmentsApi - object-oriented interface
 * @export
 * @class DepartmentsApi
 * @extends {BaseAPI}
 */
export class DepartmentsApi extends BaseAPI {
    /**
     * List departments - v1
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    departmentsListV1(options) {
        return DepartmentsApiFp(this.configuration).departmentsListV1(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List departments - v2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    departmentsListV2(options) {
        return DepartmentsApiFp(this.configuration).departmentsListV2(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get department details - v1
     * @param {DepartmentsApiDepartmentsRetrieveV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    departmentsRetrieveV1(requestParameters, options) {
        return DepartmentsApiFp(this.configuration).departmentsRetrieveV1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get department details - v2
     * @param {DepartmentsApiDepartmentsRetrieveV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DepartmentsApi
     */
    departmentsRetrieveV2(requestParameters, options) {
        return DepartmentsApiFp(this.configuration).departmentsRetrieveV2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * DiscountsApi - axios parameter creator
 * @export
 */
export const DiscountsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create an association between a user and a discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {UserDiscountMetaRequest} UserDiscountMetaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesCreate: (id_1, parent_lookup_discount_1, UserDiscountMetaRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, UserDiscountMetaRequest_1, ...args_1], void 0, function* (id, parent_lookup_discount, UserDiscountMetaRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesCreate', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesCreate', 'parent_lookup_discount', parent_lookup_discount);
            // verify required parameter 'UserDiscountMetaRequest' is not null or undefined
            assertParamExists('discountsAssigneesCreate', 'UserDiscountMetaRequest', UserDiscountMetaRequest);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(UserDiscountMetaRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a user discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesDestroy: (id_1, parent_lookup_discount_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, ...args_1], void 0, function* (id, parent_lookup_discount, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesDestroy', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesDestroy', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesList: (id_1, parent_lookup_discount_1, limit_1, offset_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, limit_1, offset_1, ...args_1], void 0, function* (id, parent_lookup_discount, limit, offset, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesList', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesList', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Partial update for a user discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedUserDiscountMetaRequest} [PatchedUserDiscountMetaRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesPartialUpdate: (id_1, parent_lookup_discount_1, PatchedUserDiscountMetaRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, PatchedUserDiscountMetaRequest_1, ...args_1], void 0, function* (id, parent_lookup_discount, PatchedUserDiscountMetaRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesPartialUpdate', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesPartialUpdate', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedUserDiscountMetaRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesRetrieve: (id_1, parent_lookup_discount_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, ...args_1], void 0, function* (id, parent_lookup_discount, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesRetrieve', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesRetrieve', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {UserDiscountMetaRequest} UserDiscountMetaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesUpdate: (id_1, parent_lookup_discount_1, UserDiscountMetaRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, UserDiscountMetaRequest_1, ...args_1], void 0, function* (id, parent_lookup_discount, UserDiscountMetaRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsAssigneesUpdate', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsAssigneesUpdate', 'parent_lookup_discount', parent_lookup_discount);
            // verify required parameter 'UserDiscountMetaRequest' is not null or undefined
            assertParamExists('discountsAssigneesUpdate', 'UserDiscountMetaRequest', UserDiscountMetaRequest);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/assignees/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(UserDiscountMetaRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discounts
         * @param {V0DiscountRequest} V0DiscountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsCreate: (V0DiscountRequest_1, ...args_1) => __awaiter(this, [V0DiscountRequest_1, ...args_1], void 0, function* (V0DiscountRequest, options = {}) {
            // verify required parameter 'V0DiscountRequest' is not null or undefined
            assertParamExists('discountsCreate', 'V0DiscountRequest', V0DiscountRequest);
            const localVarPath = `/api/v0/discounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(V0DiscountRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a batch of codes. This is used in the staff-dashboard. POST arguments are the same as in generate_discount_code - look there for details.
         * @param {V0DiscountRequest} V0DiscountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsCreateBatchCreate: (V0DiscountRequest_1, ...args_1) => __awaiter(this, [V0DiscountRequest_1, ...args_1], void 0, function* (V0DiscountRequest, options = {}) {
            // verify required parameter 'V0DiscountRequest' is not null or undefined
            assertParamExists('discountsCreateBatchCreate', 'V0DiscountRequest', V0DiscountRequest);
            const localVarPath = `/api/v0/discounts/create_batch/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(V0DiscountRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsDestroy: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsDestroy', 'id', id);
            const localVarPath = `/api/v0/discounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discounts
         * @param {DiscountsListIsRedeemedEnum} [is_redeemed] * &#x60;yes&#x60; - yes * &#x60;no&#x60; - no
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {DiscountsListPaymentTypeEnum} [payment_type] * &#x60;marketing&#x60; - marketing * &#x60;sales&#x60; - sales * &#x60;financial-assistance&#x60; - financial-assistance * &#x60;customer-support&#x60; - customer-support * &#x60;staff&#x60; - staff * &#x60;legacy&#x60; - legacy
         * @param {string} [q] q
         * @param {DiscountsListRedemptionTypeEnum} [redemption_type] * &#x60;one-time&#x60; - one-time * &#x60;one-time-per-user&#x60; - one-time-per-user * &#x60;unlimited&#x60; - unlimited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsList: (is_redeemed_1, limit_1, offset_1, payment_type_1, q_1, redemption_type_1, ...args_1) => __awaiter(this, [is_redeemed_1, limit_1, offset_1, payment_type_1, q_1, redemption_type_1, ...args_1], void 0, function* (is_redeemed, limit, offset, payment_type, q, redemption_type, options = {}) {
            const localVarPath = `/api/v0/discounts/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (is_redeemed !== undefined) {
                localVarQueryParameter['is_redeemed'] = is_redeemed;
            }
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (payment_type !== undefined) {
                localVarQueryParameter['payment_type'] = payment_type;
            }
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (redemption_type !== undefined) {
                localVarQueryParameter['redemption_type'] = redemption_type;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {PatchedV0DiscountRequest} [PatchedV0DiscountRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsPartialUpdate: (id_1, PatchedV0DiscountRequest_1, ...args_1) => __awaiter(this, [id_1, PatchedV0DiscountRequest_1, ...args_1], void 0, function* (id, PatchedV0DiscountRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsPartialUpdate', 'id', id);
            const localVarPath = `/api/v0/discounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedV0DiscountRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {DiscountProductRequest} DiscountProductRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsCreate: (id_1, parent_lookup_discount_1, DiscountProductRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, DiscountProductRequest_1, ...args_1], void 0, function* (id, parent_lookup_discount, DiscountProductRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsCreate', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsCreate', 'parent_lookup_discount', parent_lookup_discount);
            // verify required parameter 'DiscountProductRequest' is not null or undefined
            assertParamExists('discountsProductsCreate', 'DiscountProductRequest', DiscountProductRequest);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(DiscountProductRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Delete a linked product from a discount.
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsDestroy: (id_1, parent_lookup_discount_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, ...args_1], void 0, function* (id, parent_lookup_discount, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsDestroy', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsDestroy', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsList: (id_1, parent_lookup_discount_1, limit_1, offset_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, limit_1, offset_1, ...args_1], void 0, function* (id, parent_lookup_discount, limit, offset, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsList', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsList', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Partial update for a discount product.
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedDiscountProductRequest} [PatchedDiscountProductRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsPartialUpdate: (id_1, parent_lookup_discount_1, PatchedDiscountProductRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, PatchedDiscountProductRequest_1, ...args_1], void 0, function* (id, parent_lookup_discount, PatchedDiscountProductRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsPartialUpdate', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsPartialUpdate', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedDiscountProductRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsRetrieve: (id_1, parent_lookup_discount_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, ...args_1], void 0, function* (id, parent_lookup_discount, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsRetrieve', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsRetrieve', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {DiscountProductRequest} DiscountProductRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsUpdate: (id_1, parent_lookup_discount_1, DiscountProductRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, DiscountProductRequest_1, ...args_1], void 0, function* (id, parent_lookup_discount, DiscountProductRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsProductsUpdate', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsProductsUpdate', 'parent_lookup_discount', parent_lookup_discount);
            // verify required parameter 'DiscountProductRequest' is not null or undefined
            assertParamExists('discountsProductsUpdate', 'DiscountProductRequest', DiscountProductRequest);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(DiscountProductRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {DiscountRedemptionRequest} DiscountRedemptionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsCreate: (id_1, parent_lookup_redeemed_discount_1, DiscountRedemptionRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_redeemed_discount_1, DiscountRedemptionRequest_1, ...args_1], void 0, function* (id, parent_lookup_redeemed_discount, DiscountRedemptionRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsCreate', 'id', id);
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsCreate', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount);
            // verify required parameter 'DiscountRedemptionRequest' is not null or undefined
            assertParamExists('discountsRedemptionsCreate', 'DiscountRedemptionRequest', DiscountRedemptionRequest);
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(DiscountRedemptionRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsDestroy: (id_1, parent_lookup_redeemed_discount_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_redeemed_discount_1, ...args_1], void 0, function* (id, parent_lookup_redeemed_discount, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsDestroy', 'id', id);
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsDestroy', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsList: (id_1, parent_lookup_redeemed_discount_1, limit_1, offset_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_redeemed_discount_1, limit_1, offset_1, ...args_1], void 0, function* (id, parent_lookup_redeemed_discount, limit, offset, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsList', 'id', id);
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsList', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {PatchedDiscountRedemptionRequest} [PatchedDiscountRedemptionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsPartialUpdate: (id_1, parent_lookup_redeemed_discount_1, PatchedDiscountRedemptionRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_redeemed_discount_1, PatchedDiscountRedemptionRequest_1, ...args_1], void 0, function* (id, parent_lookup_redeemed_discount, PatchedDiscountRedemptionRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsPartialUpdate', 'id', id);
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsPartialUpdate', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedDiscountRedemptionRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsRetrieve: (id_1, parent_lookup_redeemed_discount_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_redeemed_discount_1, ...args_1], void 0, function* (id, parent_lookup_redeemed_discount, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsRetrieve', 'id', id);
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsRetrieve', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {DiscountRedemptionRequest} DiscountRedemptionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsUpdate: (id_1, parent_lookup_redeemed_discount_1, DiscountRedemptionRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_redeemed_discount_1, DiscountRedemptionRequest_1, ...args_1], void 0, function* (id, parent_lookup_redeemed_discount, DiscountRedemptionRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRedemptionsUpdate', 'id', id);
            // verify required parameter 'parent_lookup_redeemed_discount' is not null or undefined
            assertParamExists('discountsRedemptionsUpdate', 'parent_lookup_redeemed_discount', parent_lookup_redeemed_discount);
            // verify required parameter 'DiscountRedemptionRequest' is not null or undefined
            assertParamExists('discountsRedemptionsUpdate', 'DiscountRedemptionRequest', DiscountRedemptionRequest);
            const localVarPath = `/api/v0/discounts/{parent_lookup_redeemed_discount}/redemptions/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_redeemed_discount"}}`, encodeURIComponent(String(parent_lookup_redeemed_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(DiscountRedemptionRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsRetrieve', 'id', id);
            const localVarPath = `/api/v0/discounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {FlexiblePriceTierRequest} FlexiblePriceTierRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersCreate: (id_1, parent_lookup_discount_1, FlexiblePriceTierRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, FlexiblePriceTierRequest_1, ...args_1], void 0, function* (id, parent_lookup_discount, FlexiblePriceTierRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersCreate', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersCreate', 'parent_lookup_discount', parent_lookup_discount);
            // verify required parameter 'FlexiblePriceTierRequest' is not null or undefined
            assertParamExists('discountsTiersCreate', 'FlexiblePriceTierRequest', FlexiblePriceTierRequest);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(FlexiblePriceTierRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersDestroy: (id_1, parent_lookup_discount_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, ...args_1], void 0, function* (id, parent_lookup_discount, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersDestroy', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersDestroy', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersList: (id_1, parent_lookup_discount_1, limit_1, offset_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, limit_1, offset_1, ...args_1], void 0, function* (id, parent_lookup_discount, limit, offset, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersList', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersList', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedFlexiblePriceTierRequest} [PatchedFlexiblePriceTierRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersPartialUpdate: (id_1, parent_lookup_discount_1, PatchedFlexiblePriceTierRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, PatchedFlexiblePriceTierRequest_1, ...args_1], void 0, function* (id, parent_lookup_discount, PatchedFlexiblePriceTierRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersPartialUpdate', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersPartialUpdate', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedFlexiblePriceTierRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersRetrieve: (id_1, parent_lookup_discount_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, ...args_1], void 0, function* (id, parent_lookup_discount, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersRetrieve', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersRetrieve', 'parent_lookup_discount', parent_lookup_discount);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {FlexiblePriceTierRequest} FlexiblePriceTierRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersUpdate: (id_1, parent_lookup_discount_1, FlexiblePriceTierRequest_1, ...args_1) => __awaiter(this, [id_1, parent_lookup_discount_1, FlexiblePriceTierRequest_1, ...args_1], void 0, function* (id, parent_lookup_discount, FlexiblePriceTierRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsTiersUpdate', 'id', id);
            // verify required parameter 'parent_lookup_discount' is not null or undefined
            assertParamExists('discountsTiersUpdate', 'parent_lookup_discount', parent_lookup_discount);
            // verify required parameter 'FlexiblePriceTierRequest' is not null or undefined
            assertParamExists('discountsTiersUpdate', 'FlexiblePriceTierRequest', FlexiblePriceTierRequest);
            const localVarPath = `/api/v0/discounts/{parent_lookup_discount}/tiers/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"parent_lookup_discount"}}`, encodeURIComponent(String(parent_lookup_discount)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(FlexiblePriceTierRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {V0DiscountRequest} V0DiscountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsUpdate: (id_1, V0DiscountRequest_1, ...args_1) => __awaiter(this, [id_1, V0DiscountRequest_1, ...args_1], void 0, function* (id, V0DiscountRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('discountsUpdate', 'id', id);
            // verify required parameter 'V0DiscountRequest' is not null or undefined
            assertParamExists('discountsUpdate', 'V0DiscountRequest', V0DiscountRequest);
            const localVarPath = `/api/v0/discounts/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(V0DiscountRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * DiscountsApi - functional programming interface
 * @export
 */
export const DiscountsApiFp = function (configuration) {
    const localVarAxiosParamCreator = DiscountsApiAxiosParamCreator(configuration);
    return {
        /**
         * Create an association between a user and a discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {UserDiscountMetaRequest} UserDiscountMetaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesCreate(id, parent_lookup_discount, UserDiscountMetaRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsAssigneesCreate(id, parent_lookup_discount, UserDiscountMetaRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsAssigneesCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Delete a user discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesDestroy(id, parent_lookup_discount, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsAssigneesDestroy(id, parent_lookup_discount, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsAssigneesDestroy']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesList(id, parent_lookup_discount, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsAssigneesList(id, parent_lookup_discount, limit, offset, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsAssigneesList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Partial update for a user discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedUserDiscountMetaRequest} [PatchedUserDiscountMetaRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesPartialUpdate(id, parent_lookup_discount, PatchedUserDiscountMetaRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsAssigneesPartialUpdate(id, parent_lookup_discount, PatchedUserDiscountMetaRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsAssigneesPartialUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesRetrieve(id, parent_lookup_discount, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsAssigneesRetrieve(id, parent_lookup_discount, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsAssigneesRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {UserDiscountMetaRequest} UserDiscountMetaRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesUpdate(id, parent_lookup_discount, UserDiscountMetaRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsAssigneesUpdate(id, parent_lookup_discount, UserDiscountMetaRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsAssigneesUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discounts
         * @param {V0DiscountRequest} V0DiscountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsCreate(V0DiscountRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsCreate(V0DiscountRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Create a batch of codes. This is used in the staff-dashboard. POST arguments are the same as in generate_discount_code - look there for details.
         * @param {V0DiscountRequest} V0DiscountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsCreateBatchCreate(V0DiscountRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsCreateBatchCreate(V0DiscountRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsCreateBatchCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsDestroy(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsDestroy(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsDestroy']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discounts
         * @param {DiscountsListIsRedeemedEnum} [is_redeemed] * &#x60;yes&#x60; - yes * &#x60;no&#x60; - no
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {DiscountsListPaymentTypeEnum} [payment_type] * &#x60;marketing&#x60; - marketing * &#x60;sales&#x60; - sales * &#x60;financial-assistance&#x60; - financial-assistance * &#x60;customer-support&#x60; - customer-support * &#x60;staff&#x60; - staff * &#x60;legacy&#x60; - legacy
         * @param {string} [q] q
         * @param {DiscountsListRedemptionTypeEnum} [redemption_type] * &#x60;one-time&#x60; - one-time * &#x60;one-time-per-user&#x60; - one-time-per-user * &#x60;unlimited&#x60; - unlimited
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsList(is_redeemed, limit, offset, payment_type, q, redemption_type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsList(is_redeemed, limit, offset, payment_type, q, redemption_type, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {PatchedV0DiscountRequest} [PatchedV0DiscountRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsPartialUpdate(id, PatchedV0DiscountRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsPartialUpdate(id, PatchedV0DiscountRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsPartialUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {DiscountProductRequest} DiscountProductRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsCreate(id, parent_lookup_discount, DiscountProductRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsProductsCreate(id, parent_lookup_discount, DiscountProductRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsProductsCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Delete a linked product from a discount.
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsDestroy(id, parent_lookup_discount, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsProductsDestroy(id, parent_lookup_discount, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsProductsDestroy']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsList(id, parent_lookup_discount, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsProductsList(id, parent_lookup_discount, limit, offset, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsProductsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Partial update for a discount product.
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedDiscountProductRequest} [PatchedDiscountProductRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsPartialUpdate(id, parent_lookup_discount, PatchedDiscountProductRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsProductsPartialUpdate(id, parent_lookup_discount, PatchedDiscountProductRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsProductsPartialUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsRetrieve(id, parent_lookup_discount, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsProductsRetrieve(id, parent_lookup_discount, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsProductsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discounts
         * @param {number} id ID of the discount product
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {DiscountProductRequest} DiscountProductRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsUpdate(id, parent_lookup_discount, DiscountProductRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsProductsUpdate(id, parent_lookup_discount, DiscountProductRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsProductsUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {DiscountRedemptionRequest} DiscountRedemptionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsCreate(id, parent_lookup_redeemed_discount, DiscountRedemptionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsRedemptionsCreate(id, parent_lookup_redeemed_discount, DiscountRedemptionRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsRedemptionsCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsDestroy(id, parent_lookup_redeemed_discount, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsRedemptionsDestroy(id, parent_lookup_redeemed_discount, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsRedemptionsDestroy']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsList(id, parent_lookup_redeemed_discount, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsRedemptionsList(id, parent_lookup_redeemed_discount, limit, offset, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsRedemptionsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {PatchedDiscountRedemptionRequest} [PatchedDiscountRedemptionRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsPartialUpdate(id, parent_lookup_redeemed_discount, PatchedDiscountRedemptionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsRedemptionsPartialUpdate(id, parent_lookup_redeemed_discount, PatchedDiscountRedemptionRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsRedemptionsPartialUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsRetrieve(id, parent_lookup_redeemed_discount, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsRedemptionsRetrieve(id, parent_lookup_redeemed_discount, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsRedemptionsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discount Redemptions
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_redeemed_discount ID of the parent discount
         * @param {DiscountRedemptionRequest} DiscountRedemptionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsUpdate(id, parent_lookup_redeemed_discount, DiscountRedemptionRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsRedemptionsUpdate(id, parent_lookup_redeemed_discount, DiscountRedemptionRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsRedemptionsUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {FlexiblePriceTierRequest} FlexiblePriceTierRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersCreate(id, parent_lookup_discount, FlexiblePriceTierRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsTiersCreate(id, parent_lookup_discount, FlexiblePriceTierRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsTiersCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersDestroy(id, parent_lookup_discount, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsTiersDestroy(id, parent_lookup_discount, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsTiersDestroy']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersList(id, parent_lookup_discount, limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsTiersList(id, parent_lookup_discount, limit, offset, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsTiersList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {PatchedFlexiblePriceTierRequest} [PatchedFlexiblePriceTierRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersPartialUpdate(id, parent_lookup_discount, PatchedFlexiblePriceTierRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsTiersPartialUpdate(id, parent_lookup_discount, PatchedFlexiblePriceTierRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsTiersPartialUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersRetrieve(id, parent_lookup_discount, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsTiersRetrieve(id, parent_lookup_discount, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsTiersRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {number} id ID of the user discount
         * @param {number} parent_lookup_discount ID of the parent discount
         * @param {FlexiblePriceTierRequest} FlexiblePriceTierRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersUpdate(id, parent_lookup_discount, FlexiblePriceTierRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsTiersUpdate(id, parent_lookup_discount, FlexiblePriceTierRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsTiersUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Discounts
         * @param {number} id A unique integer value identifying this discount.
         * @param {V0DiscountRequest} V0DiscountRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsUpdate(id, V0DiscountRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.discountsUpdate(id, V0DiscountRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['DiscountsApi.discountsUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * DiscountsApi - factory interface
 * @export
 */
export const DiscountsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = DiscountsApiFp(configuration);
    return {
        /**
         * Create an association between a user and a discount.
         * @param {DiscountsApiDiscountsAssigneesCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesCreate(requestParameters, options) {
            return localVarFp.discountsAssigneesCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.UserDiscountMetaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user discount.
         * @param {DiscountsApiDiscountsAssigneesDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesDestroy(requestParameters, options) {
            return localVarFp.discountsAssigneesDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsAssigneesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesList(requestParameters, options) {
            return localVarFp.discountsAssigneesList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Partial update for a user discount.
         * @param {DiscountsApiDiscountsAssigneesPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesPartialUpdate(requestParameters, options) {
            return localVarFp.discountsAssigneesPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedUserDiscountMetaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsAssigneesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesRetrieve(requestParameters, options) {
            return localVarFp.discountsAssigneesRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for User Discounts. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsAssigneesUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsAssigneesUpdate(requestParameters, options) {
            return localVarFp.discountsAssigneesUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.UserDiscountMetaRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsCreate(requestParameters, options) {
            return localVarFp.discountsCreate(requestParameters.V0DiscountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a batch of codes. This is used in the staff-dashboard. POST arguments are the same as in generate_discount_code - look there for details.
         * @param {DiscountsApiDiscountsCreateBatchCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsCreateBatchCreate(requestParameters, options) {
            return localVarFp.discountsCreateBatchCreate(requestParameters.V0DiscountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsDestroy(requestParameters, options) {
            return localVarFp.discountsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsList(requestParameters = {}, options) {
            return localVarFp.discountsList(requestParameters.is_redeemed, requestParameters.limit, requestParameters.offset, requestParameters.payment_type, requestParameters.q, requestParameters.redemption_type, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsPartialUpdate(requestParameters, options) {
            return localVarFp.discountsPartialUpdate(requestParameters.id, requestParameters.PatchedV0DiscountRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsProductsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsCreate(requestParameters, options) {
            return localVarFp.discountsProductsCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.DiscountProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a linked product from a discount.
         * @param {DiscountsApiDiscountsProductsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsDestroy(requestParameters, options) {
            return localVarFp.discountsProductsDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsProductsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsList(requestParameters, options) {
            return localVarFp.discountsProductsList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Partial update for a discount product.
         * @param {DiscountsApiDiscountsProductsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsPartialUpdate(requestParameters, options) {
            return localVarFp.discountsProductsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedDiscountProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsProductsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsRetrieve(requestParameters, options) {
            return localVarFp.discountsProductsRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsProductsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsProductsUpdate(requestParameters, options) {
            return localVarFp.discountsProductsUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.DiscountProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsCreate(requestParameters, options) {
            return localVarFp.discountsRedemptionsCreate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.DiscountRedemptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsDestroy(requestParameters, options) {
            return localVarFp.discountsRedemptionsDestroy(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsList(requestParameters, options) {
            return localVarFp.discountsRedemptionsList(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsPartialUpdate(requestParameters, options) {
            return localVarFp.discountsRedemptionsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.PatchedDiscountRedemptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsRetrieve(requestParameters, options) {
            return localVarFp.discountsRedemptionsRetrieve(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discount Redemptions
         * @param {DiscountsApiDiscountsRedemptionsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRedemptionsUpdate(requestParameters, options) {
            return localVarFp.discountsRedemptionsUpdate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.DiscountRedemptionRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsRetrieve(requestParameters, options) {
            return localVarFp.discountsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersCreate(requestParameters, options) {
            return localVarFp.discountsTiersCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.FlexiblePriceTierRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersDestroy(requestParameters, options) {
            return localVarFp.discountsTiersDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersList(requestParameters, options) {
            return localVarFp.discountsTiersList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersPartialUpdate(requestParameters, options) {
            return localVarFp.discountsTiersPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedFlexiblePriceTierRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersRetrieve(requestParameters, options) {
            return localVarFp.discountsTiersRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
         * @param {DiscountsApiDiscountsTiersUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsTiersUpdate(requestParameters, options) {
            return localVarFp.discountsTiersUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.FlexiblePriceTierRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Discounts
         * @param {DiscountsApiDiscountsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        discountsUpdate(requestParameters, options) {
            return localVarFp.discountsUpdate(requestParameters.id, requestParameters.V0DiscountRequest, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * DiscountsApi - object-oriented interface
 * @export
 * @class DiscountsApi
 * @extends {BaseAPI}
 */
export class DiscountsApi extends BaseAPI {
    /**
     * Create an association between a user and a discount.
     * @param {DiscountsApiDiscountsAssigneesCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsAssigneesCreate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsAssigneesCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.UserDiscountMetaRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a user discount.
     * @param {DiscountsApiDiscountsAssigneesDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsAssigneesDestroy(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsAssigneesDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for User Discounts. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsAssigneesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsAssigneesList(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsAssigneesList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Partial update for a user discount.
     * @param {DiscountsApiDiscountsAssigneesPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsAssigneesPartialUpdate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsAssigneesPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedUserDiscountMetaRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for User Discounts. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsAssigneesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsAssigneesRetrieve(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsAssigneesRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for User Discounts. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsAssigneesUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsAssigneesUpdate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsAssigneesUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.UserDiscountMetaRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsCreate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsCreate(requestParameters.V0DiscountRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a batch of codes. This is used in the staff-dashboard. POST arguments are the same as in generate_discount_code - look there for details.
     * @param {DiscountsApiDiscountsCreateBatchCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsCreateBatchCreate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsCreateBatchCreate(requestParameters.V0DiscountRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsDestroy(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsList(requestParameters = {}, options) {
        return DiscountsApiFp(this.configuration).discountsList(requestParameters.is_redeemed, requestParameters.limit, requestParameters.offset, requestParameters.payment_type, requestParameters.q, requestParameters.redemption_type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsPartialUpdate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsPartialUpdate(requestParameters.id, requestParameters.PatchedV0DiscountRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsProductsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsProductsCreate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsProductsCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.DiscountProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Delete a linked product from a discount.
     * @param {DiscountsApiDiscountsProductsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsProductsDestroy(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsProductsDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsProductsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsProductsList(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsProductsList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Partial update for a discount product.
     * @param {DiscountsApiDiscountsProductsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsProductsPartialUpdate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsProductsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedDiscountProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsProductsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsProductsRetrieve(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsProductsRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsProductsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsProductsUpdate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsProductsUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.DiscountProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsRedemptionsCreate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsCreate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.DiscountRedemptionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsRedemptionsDestroy(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsDestroy(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsRedemptionsList(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsList(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsRedemptionsPartialUpdate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsPartialUpdate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.PatchedDiscountRedemptionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsRedemptionsRetrieve(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsRetrieve(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discount Redemptions
     * @param {DiscountsApiDiscountsRedemptionsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsRedemptionsUpdate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsRedemptionsUpdate(requestParameters.id, requestParameters.parent_lookup_redeemed_discount, requestParameters.DiscountRedemptionRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsRetrieve(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsTiersCreate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsTiersCreate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.FlexiblePriceTierRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsTiersDestroy(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsTiersDestroy(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsTiersList(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsTiersList(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsTiersPartialUpdate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsTiersPartialUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.PatchedFlexiblePriceTierRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsTiersRetrieve(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsTiersRetrieve(requestParameters.id, requestParameters.parent_lookup_discount, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Flexible Pricing Tiers. This one is for use within a Discount.
     * @param {DiscountsApiDiscountsTiersUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsTiersUpdate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsTiersUpdate(requestParameters.id, requestParameters.parent_lookup_discount, requestParameters.FlexiblePriceTierRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Discounts
     * @param {DiscountsApiDiscountsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    discountsUpdate(requestParameters, options) {
        return DiscountsApiFp(this.configuration).discountsUpdate(requestParameters.id, requestParameters.V0DiscountRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * @export
 */
export const DiscountsListIsRedeemedEnum = {
    No: 'no',
    Yes: 'yes'
};
/**
 * @export
 */
export const DiscountsListPaymentTypeEnum = {
    CustomerSupport: 'customer-support',
    FinancialAssistance: 'financial-assistance',
    Legacy: 'legacy',
    Marketing: 'marketing',
    Sales: 'sales',
    Staff: 'staff'
};
/**
 * @export
 */
export const DiscountsListRedemptionTypeEnum = {
    OneTime: 'one-time',
    OneTimePerUser: 'one-time-per-user',
    Unlimited: 'unlimited'
};
/**
 * EnrollmentsApi - axios parameter creator
 * @export
 */
export const EnrollmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * View to handle direct POST requests to enroll in a course run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEnrollmentsCreate: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for user enrollments
         * @param {CourseRunEnrollmentRequest} CourseRunEnrollmentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsCreate: (CourseRunEnrollmentRequest_1, ...args_1) => __awaiter(this, [CourseRunEnrollmentRequest_1, ...args_1], void 0, function* (CourseRunEnrollmentRequest, options = {}) {
            // verify required parameter 'CourseRunEnrollmentRequest' is not null or undefined
            assertParamExists('enrollmentsCreate', 'CourseRunEnrollmentRequest', CourseRunEnrollmentRequest);
            const localVarPath = `/api/v1/enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(CourseRunEnrollmentRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for user enrollments
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsDestroy: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enrollmentsDestroy', 'id', id);
            const localVarPath = `/api/v1/enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for user enrollments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsList: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v1/enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Update enrollment email preferences
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {PatchedUpdateCourseRunEnrollmentRequest} [PatchedUpdateCourseRunEnrollmentRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsPartialUpdate: (id_1, PatchedUpdateCourseRunEnrollmentRequest_1, ...args_1) => __awaiter(this, [id_1, PatchedUpdateCourseRunEnrollmentRequest_1, ...args_1], void 0, function* (id, PatchedUpdateCourseRunEnrollmentRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enrollmentsPartialUpdate', 'id', id);
            const localVarPath = `/api/v1/enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedUpdateCourseRunEnrollmentRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for user enrollments
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {CourseRunEnrollmentRequest} CourseRunEnrollmentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsUpdate: (id_1, CourseRunEnrollmentRequest_1, ...args_1) => __awaiter(this, [id_1, CourseRunEnrollmentRequest_1, ...args_1], void 0, function* (id, CourseRunEnrollmentRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('enrollmentsUpdate', 'id', id);
            // verify required parameter 'CourseRunEnrollmentRequest' is not null or undefined
            assertParamExists('enrollmentsUpdate', 'CourseRunEnrollmentRequest', CourseRunEnrollmentRequest);
            const localVarPath = `/api/v1/enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(CourseRunEnrollmentRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Create a new user enrollment - API v2
         * @param {CourseRunEnrollmentRequestV2Request} CourseRunEnrollmentRequestV2Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsCreateV2: (CourseRunEnrollmentRequestV2Request_1, ...args_1) => __awaiter(this, [CourseRunEnrollmentRequestV2Request_1, ...args_1], void 0, function* (CourseRunEnrollmentRequestV2Request, options = {}) {
            // verify required parameter 'CourseRunEnrollmentRequestV2Request' is not null or undefined
            assertParamExists('userEnrollmentsCreateV2', 'CourseRunEnrollmentRequestV2Request', CourseRunEnrollmentRequestV2Request);
            const localVarPath = `/api/v2/enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(CourseRunEnrollmentRequestV2Request, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Unenroll from a course - API v2
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsDestroyV2: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userEnrollmentsDestroyV2', 'id', id);
            const localVarPath = `/api/v2/enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List user enrollments with B2B organization and contract information - API v2. Use ?exclude_b2b=true to filter out enrollments linked to course runs with B2B contracts. Use ?org_id=<id> to filter enrollments by specific B2B organization.
         * @param {boolean} [exclude_b2b] Exclude B2B enrollments (enrollments linked to course runs with B2B contracts)
         * @param {number} [org_id] Filter by B2B organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsListV2: (exclude_b2b_1, org_id_1, ...args_1) => __awaiter(this, [exclude_b2b_1, org_id_1, ...args_1], void 0, function* (exclude_b2b, org_id, options = {}) {
            const localVarPath = `/api/v2/enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (exclude_b2b !== undefined) {
                localVarQueryParameter['exclude_b2b'] = exclude_b2b;
            }
            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * EnrollmentsApi - functional programming interface
 * @export
 */
export const EnrollmentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = EnrollmentsApiAxiosParamCreator(configuration);
    return {
        /**
         * View to handle direct POST requests to enroll in a course run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEnrollmentsCreate(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.apiEnrollmentsCreate(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['EnrollmentsApi.apiEnrollmentsCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for user enrollments
         * @param {CourseRunEnrollmentRequest} CourseRunEnrollmentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsCreate(CourseRunEnrollmentRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.enrollmentsCreate(CourseRunEnrollmentRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['EnrollmentsApi.enrollmentsCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for user enrollments
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsDestroy(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.enrollmentsDestroy(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['EnrollmentsApi.enrollmentsDestroy']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for user enrollments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.enrollmentsList(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['EnrollmentsApi.enrollmentsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Update enrollment email preferences
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {PatchedUpdateCourseRunEnrollmentRequest} [PatchedUpdateCourseRunEnrollmentRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsPartialUpdate(id, PatchedUpdateCourseRunEnrollmentRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.enrollmentsPartialUpdate(id, PatchedUpdateCourseRunEnrollmentRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['EnrollmentsApi.enrollmentsPartialUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for user enrollments
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {CourseRunEnrollmentRequest} CourseRunEnrollmentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsUpdate(id, CourseRunEnrollmentRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.enrollmentsUpdate(id, CourseRunEnrollmentRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['EnrollmentsApi.enrollmentsUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Create a new user enrollment - API v2
         * @param {CourseRunEnrollmentRequestV2Request} CourseRunEnrollmentRequestV2Request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsCreateV2(CourseRunEnrollmentRequestV2Request, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.userEnrollmentsCreateV2(CourseRunEnrollmentRequestV2Request, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['EnrollmentsApi.userEnrollmentsCreateV2']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Unenroll from a course - API v2
         * @param {number} id A unique integer value identifying this course run enrollment.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsDestroyV2(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.userEnrollmentsDestroyV2(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['EnrollmentsApi.userEnrollmentsDestroyV2']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * List user enrollments with B2B organization and contract information - API v2. Use ?exclude_b2b=true to filter out enrollments linked to course runs with B2B contracts. Use ?org_id=<id> to filter enrollments by specific B2B organization.
         * @param {boolean} [exclude_b2b] Exclude B2B enrollments (enrollments linked to course runs with B2B contracts)
         * @param {number} [org_id] Filter by B2B organization ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsListV2(exclude_b2b, org_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.userEnrollmentsListV2(exclude_b2b, org_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['EnrollmentsApi.userEnrollmentsListV2']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * EnrollmentsApi - factory interface
 * @export
 */
export const EnrollmentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = EnrollmentsApiFp(configuration);
    return {
        /**
         * View to handle direct POST requests to enroll in a course run.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiEnrollmentsCreate(options) {
            return localVarFp.apiEnrollmentsCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for user enrollments
         * @param {EnrollmentsApiEnrollmentsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsCreate(requestParameters, options) {
            return localVarFp.enrollmentsCreate(requestParameters.CourseRunEnrollmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for user enrollments
         * @param {EnrollmentsApiEnrollmentsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsDestroy(requestParameters, options) {
            return localVarFp.enrollmentsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for user enrollments
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsList(options) {
            return localVarFp.enrollmentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Update enrollment email preferences
         * @param {EnrollmentsApiEnrollmentsPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsPartialUpdate(requestParameters, options) {
            return localVarFp.enrollmentsPartialUpdate(requestParameters.id, requestParameters.PatchedUpdateCourseRunEnrollmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for user enrollments
         * @param {EnrollmentsApiEnrollmentsUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        enrollmentsUpdate(requestParameters, options) {
            return localVarFp.enrollmentsUpdate(requestParameters.id, requestParameters.CourseRunEnrollmentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new user enrollment - API v2
         * @param {EnrollmentsApiUserEnrollmentsCreateV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsCreateV2(requestParameters, options) {
            return localVarFp.userEnrollmentsCreateV2(requestParameters.CourseRunEnrollmentRequestV2Request, options).then((request) => request(axios, basePath));
        },
        /**
         * Unenroll from a course - API v2
         * @param {EnrollmentsApiUserEnrollmentsDestroyV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsDestroyV2(requestParameters, options) {
            return localVarFp.userEnrollmentsDestroyV2(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * List user enrollments with B2B organization and contract information - API v2. Use ?exclude_b2b=true to filter out enrollments linked to course runs with B2B contracts. Use ?org_id=<id> to filter enrollments by specific B2B organization.
         * @param {EnrollmentsApiUserEnrollmentsListV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userEnrollmentsListV2(requestParameters = {}, options) {
            return localVarFp.userEnrollmentsListV2(requestParameters.exclude_b2b, requestParameters.org_id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * EnrollmentsApi - object-oriented interface
 * @export
 * @class EnrollmentsApi
 * @extends {BaseAPI}
 */
export class EnrollmentsApi extends BaseAPI {
    /**
     * View to handle direct POST requests to enroll in a course run.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    apiEnrollmentsCreate(options) {
        return EnrollmentsApiFp(this.configuration).apiEnrollmentsCreate(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for user enrollments
     * @param {EnrollmentsApiEnrollmentsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    enrollmentsCreate(requestParameters, options) {
        return EnrollmentsApiFp(this.configuration).enrollmentsCreate(requestParameters.CourseRunEnrollmentRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for user enrollments
     * @param {EnrollmentsApiEnrollmentsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    enrollmentsDestroy(requestParameters, options) {
        return EnrollmentsApiFp(this.configuration).enrollmentsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for user enrollments
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    enrollmentsList(options) {
        return EnrollmentsApiFp(this.configuration).enrollmentsList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update enrollment email preferences
     * @param {EnrollmentsApiEnrollmentsPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    enrollmentsPartialUpdate(requestParameters, options) {
        return EnrollmentsApiFp(this.configuration).enrollmentsPartialUpdate(requestParameters.id, requestParameters.PatchedUpdateCourseRunEnrollmentRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for user enrollments
     * @param {EnrollmentsApiEnrollmentsUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    enrollmentsUpdate(requestParameters, options) {
        return EnrollmentsApiFp(this.configuration).enrollmentsUpdate(requestParameters.id, requestParameters.CourseRunEnrollmentRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Create a new user enrollment - API v2
     * @param {EnrollmentsApiUserEnrollmentsCreateV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    userEnrollmentsCreateV2(requestParameters, options) {
        return EnrollmentsApiFp(this.configuration).userEnrollmentsCreateV2(requestParameters.CourseRunEnrollmentRequestV2Request, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unenroll from a course - API v2
     * @param {EnrollmentsApiUserEnrollmentsDestroyV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    userEnrollmentsDestroyV2(requestParameters, options) {
        return EnrollmentsApiFp(this.configuration).userEnrollmentsDestroyV2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List user enrollments with B2B organization and contract information - API v2. Use ?exclude_b2b=true to filter out enrollments linked to course runs with B2B contracts. Use ?org_id=<id> to filter enrollments by specific B2B organization.
     * @param {EnrollmentsApiUserEnrollmentsListV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EnrollmentsApi
     */
    userEnrollmentsListV2(requestParameters = {}, options) {
        return EnrollmentsApiFp(this.configuration).userEnrollmentsListV2(requestParameters.exclude_b2b, requestParameters.org_id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrives the current user\'s order history.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersHistoryList: (limit_1, offset_1, ...args_1) => __awaiter(this, [limit_1, offset_1, ...args_1], void 0, function* (limit, offset, options = {}) {
            const localVarPath = `/api/v0/orders/history/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a historical order for the current user.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersHistoryRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersHistoryRetrieve', 'id', id);
            const localVarPath = `/api/v0/orders/history/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Viewset to retrieve an order so it can be viewed as a receipt.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersReceiptRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ordersReceiptRetrieve', 'id', id);
            const localVarPath = `/api/v0/orders/receipt/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function (configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrives the current user\'s order history.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersHistoryList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ordersHistoryList(limit, offset, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['OrdersApi.ordersHistoryList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Retrieve a historical order for the current user.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersHistoryRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ordersHistoryRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['OrdersApi.ordersHistoryRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Viewset to retrieve an order so it can be viewed as a receipt.
         * @param {number} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersReceiptRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ordersReceiptRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['OrdersApi.ordersReceiptRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = OrdersApiFp(configuration);
    return {
        /**
         * Retrives the current user\'s order history.
         * @param {OrdersApiOrdersHistoryListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersHistoryList(requestParameters = {}, options) {
            return localVarFp.ordersHistoryList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a historical order for the current user.
         * @param {OrdersApiOrdersHistoryRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersHistoryRetrieve(requestParameters, options) {
            return localVarFp.ordersHistoryRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Viewset to retrieve an order so it can be viewed as a receipt.
         * @param {OrdersApiOrdersReceiptRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ordersReceiptRetrieve(requestParameters, options) {
            return localVarFp.ordersReceiptRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Retrives the current user\'s order history.
     * @param {OrdersApiOrdersHistoryListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    ordersHistoryList(requestParameters = {}, options) {
        return OrdersApiFp(this.configuration).ordersHistoryList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a historical order for the current user.
     * @param {OrdersApiOrdersHistoryRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    ordersHistoryRetrieve(requestParameters, options) {
        return OrdersApiFp(this.configuration).ordersHistoryRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Viewset to retrieve an order so it can be viewed as a receipt.
     * @param {OrdersApiOrdersReceiptRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    ordersReceiptRetrieve(requestParameters, options) {
        return OrdersApiFp(this.configuration).ordersReceiptRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * PagesApi - axios parameter creator
 * @export
 */
export const PagesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns pages of all types
         * @summary List all Wagtail Pages
         * @param {string} [fields] Specify fields (e.g. &#x60;*&#x60;)
         * @param {string} [type] Filter by Wagtail page type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesList: (fields_1, type_1, ...args_1) => __awaiter(this, [fields_1, type_1, ...args_1], void 0, function* (fields, type, options = {}) {
            const localVarPath = `/api/v2/pages/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (fields !== undefined) {
                localVarQueryParameter['fields'] = fields;
            }
            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns details of a specific Wagtail page by ID
         * @summary Get Wagtail Page Details
         * @param {number} id ID of the Wagtail page
         * @param {number} [revision_id] Optional certificate revision ID to retrieve a specific revision of the certificate page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesRetrieve: (id_1, revision_id_1, ...args_1) => __awaiter(this, [id_1, revision_id_1, ...args_1], void 0, function* (id, revision_id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('pagesRetrieve', 'id', id);
            const localVarPath = `/api/v2/pages/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (revision_id !== undefined) {
                localVarQueryParameter['revision_id'] = revision_id;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns pages of type cms.CertificatePage
         * @summary List all Certificate Pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsCertificatepageRetrieve: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v2/pages/?fields=*&type=cms.certificatepage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns pages of type cms.CoursePage
         * @summary List all Course Pages
         * @param {string} [readable_id] filter by course readable_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsCoursepageRetrieve: (readable_id_1, ...args_1) => __awaiter(this, [readable_id_1, ...args_1], void 0, function* (readable_id, options = {}) {
            const localVarPath = `/api/v2/pages/?fields=*&type=cms.coursepage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns pages of type cms.ProgramPage
         * @summary List all Program Pages
         * @param {string} [readable_id] filter by program readable_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsProgrampageRetrieve: (readable_id_1, ...args_1) => __awaiter(this, [readable_id_1, ...args_1], void 0, function* (readable_id, options = {}) {
            const localVarPath = `/api/v2/pages/?fields=*&type=cms.programpage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * PagesApi - functional programming interface
 * @export
 */
export const PagesApiFp = function (configuration) {
    const localVarAxiosParamCreator = PagesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns pages of all types
         * @summary List all Wagtail Pages
         * @param {string} [fields] Specify fields (e.g. &#x60;*&#x60;)
         * @param {string} [type] Filter by Wagtail page type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesList(fields, type, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.pagesList(fields, type, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['PagesApi.pagesList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns details of a specific Wagtail page by ID
         * @summary Get Wagtail Page Details
         * @param {number} id ID of the Wagtail page
         * @param {number} [revision_id] Optional certificate revision ID to retrieve a specific revision of the certificate page
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesRetrieve(id, revision_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.pagesRetrieve(id, revision_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['PagesApi.pagesRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns pages of type cms.CertificatePage
         * @summary List all Certificate Pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsCertificatepageRetrieve(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.pagesfieldstypecmsCertificatepageRetrieve(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['PagesApi.pagesfieldstypecmsCertificatepageRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns pages of type cms.CoursePage
         * @summary List all Course Pages
         * @param {string} [readable_id] filter by course readable_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsCoursepageRetrieve(readable_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.pagesfieldstypecmsCoursepageRetrieve(readable_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['PagesApi.pagesfieldstypecmsCoursepageRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns pages of type cms.ProgramPage
         * @summary List all Program Pages
         * @param {string} [readable_id] filter by program readable_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsProgrampageRetrieve(readable_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.pagesfieldstypecmsProgrampageRetrieve(readable_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['PagesApi.pagesfieldstypecmsProgrampageRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * PagesApi - factory interface
 * @export
 */
export const PagesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = PagesApiFp(configuration);
    return {
        /**
         * Returns pages of all types
         * @summary List all Wagtail Pages
         * @param {PagesApiPagesListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesList(requestParameters = {}, options) {
            return localVarFp.pagesList(requestParameters.fields, requestParameters.type, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns details of a specific Wagtail page by ID
         * @summary Get Wagtail Page Details
         * @param {PagesApiPagesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesRetrieve(requestParameters, options) {
            return localVarFp.pagesRetrieve(requestParameters.id, requestParameters.revision_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns pages of type cms.CertificatePage
         * @summary List all Certificate Pages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsCertificatepageRetrieve(options) {
            return localVarFp.pagesfieldstypecmsCertificatepageRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns pages of type cms.CoursePage
         * @summary List all Course Pages
         * @param {PagesApiPagesfieldstypecmsCoursepageRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsCoursepageRetrieve(requestParameters = {}, options) {
            return localVarFp.pagesfieldstypecmsCoursepageRetrieve(requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns pages of type cms.ProgramPage
         * @summary List all Program Pages
         * @param {PagesApiPagesfieldstypecmsProgrampageRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pagesfieldstypecmsProgrampageRetrieve(requestParameters = {}, options) {
            return localVarFp.pagesfieldstypecmsProgrampageRetrieve(requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * PagesApi - object-oriented interface
 * @export
 * @class PagesApi
 * @extends {BaseAPI}
 */
export class PagesApi extends BaseAPI {
    /**
     * Returns pages of all types
     * @summary List all Wagtail Pages
     * @param {PagesApiPagesListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    pagesList(requestParameters = {}, options) {
        return PagesApiFp(this.configuration).pagesList(requestParameters.fields, requestParameters.type, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns details of a specific Wagtail page by ID
     * @summary Get Wagtail Page Details
     * @param {PagesApiPagesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    pagesRetrieve(requestParameters, options) {
        return PagesApiFp(this.configuration).pagesRetrieve(requestParameters.id, requestParameters.revision_id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns pages of type cms.CertificatePage
     * @summary List all Certificate Pages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    pagesfieldstypecmsCertificatepageRetrieve(options) {
        return PagesApiFp(this.configuration).pagesfieldstypecmsCertificatepageRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns pages of type cms.CoursePage
     * @summary List all Course Pages
     * @param {PagesApiPagesfieldstypecmsCoursepageRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    pagesfieldstypecmsCoursepageRetrieve(requestParameters = {}, options) {
        return PagesApiFp(this.configuration).pagesfieldstypecmsCoursepageRetrieve(requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns pages of type cms.ProgramPage
     * @summary List all Program Pages
     * @param {PagesApiPagesfieldstypecmsProgrampageRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PagesApi
     */
    pagesfieldstypecmsProgrampageRetrieve(requestParameters = {}, options) {
        return PagesApiFp(this.configuration).pagesfieldstypecmsProgrampageRetrieve(requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductRequest} ProductRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllCreate: (ProductRequest_1, ...args_1) => __awaiter(this, [ProductRequest_1, ...args_1], void 0, function* (ProductRequest, options = {}) {
            // verify required parameter 'ProductRequest' is not null or undefined
            assertParamExists('productsAllCreate', 'ProductRequest', ProductRequest);
            const localVarPath = `/api/v0/products/all/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(ProductRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllDestroy: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsAllDestroy', 'id', id);
            const localVarPath = `/api/v0/products/all/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllList: (limit_1, offset_1, ...args_1) => __awaiter(this, [limit_1, offset_1, ...args_1], void 0, function* (limit, offset, options = {}) {
            const localVarPath = `/api/v0/products/all/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {PatchedProductRequest} [PatchedProductRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllPartialUpdate: (id_1, PatchedProductRequest_1, ...args_1) => __awaiter(this, [id_1, PatchedProductRequest_1, ...args_1], void 0, function* (id, PatchedProductRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsAllPartialUpdate', 'id', id);
            const localVarPath = `/api/v0/products/all/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedProductRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsAllRetrieve', 'id', id);
            const localVarPath = `/api/v0/products/all/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {ProductRequest} ProductRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllUpdate: (id_1, ProductRequest_1, ...args_1) => __awaiter(this, [id_1, ProductRequest_1, ...args_1], void 0, function* (id, ProductRequest, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsAllUpdate', 'id', id);
            // verify required parameter 'ProductRequest' is not null or undefined
            assertParamExists('productsAllUpdate', 'ProductRequest', ProductRequest);
            const localVarPath = `/api/v0/products/all/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PUT' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(ProductRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List and view products within the system.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsList: (limit_1, offset_1, ...args_1) => __awaiter(this, [limit_1, offset_1, ...args_1], void 0, function* (limit, offset, options = {}) {
            const localVarPath = `/api/v0/products/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List and view products within the system.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsRetrieve', 'id', id);
            const localVarPath = `/api/v0/products/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a product with user-specific flexible price information
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsUserFlexiblePriceRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('productsUserFlexiblePriceRetrieve', 'id', id);
            const localVarPath = `/api/v0/products/{id}/user_flexible_price/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration);
    return {
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductRequest} ProductRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllCreate(ProductRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.productsAllCreate(ProductRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProductsApi.productsAllCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllDestroy(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.productsAllDestroy(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProductsApi.productsAllDestroy']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.productsAllList(limit, offset, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProductsApi.productsAllList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {PatchedProductRequest} [PatchedProductRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllPartialUpdate(id, PatchedProductRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.productsAllPartialUpdate(id, PatchedProductRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProductsApi.productsAllPartialUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.productsAllRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProductsApi.productsAllRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {number} id A unique integer value identifying this product.
         * @param {ProductRequest} ProductRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllUpdate(id, ProductRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.productsAllUpdate(id, ProductRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProductsApi.productsAllUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * List and view products within the system.
         * @param {number} [limit] Number of results to return per page.
         * @param {number} [offset] The initial index from which to return the results.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsList(limit, offset, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.productsList(limit, offset, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProductsApi.productsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * List and view products within the system.
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.productsRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProductsApi.productsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Retrieve a product with user-specific flexible price information
         * @param {number} id A unique integer value identifying this product.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsUserFlexiblePriceRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.productsUserFlexiblePriceRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProductsApi.productsUserFlexiblePriceRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ProductsApiFp(configuration);
    return {
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllCreate(requestParameters, options) {
            return localVarFp.productsAllCreate(requestParameters.ProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllDestroy(requestParameters, options) {
            return localVarFp.productsAllDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllList(requestParameters = {}, options) {
            return localVarFp.productsAllList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllPartialUpdate(requestParameters, options) {
            return localVarFp.productsAllPartialUpdate(requestParameters.id, requestParameters.PatchedProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllRetrieve(requestParameters, options) {
            return localVarFp.productsAllRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
         * @param {ProductsApiProductsAllUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsAllUpdate(requestParameters, options) {
            return localVarFp.productsAllUpdate(requestParameters.id, requestParameters.ProductRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List and view products within the system.
         * @param {ProductsApiProductsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsList(requestParameters = {}, options) {
            return localVarFp.productsList(requestParameters.limit, requestParameters.offset, options).then((request) => request(axios, basePath));
        },
        /**
         * List and view products within the system.
         * @param {ProductsApiProductsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsRetrieve(requestParameters, options) {
            return localVarFp.productsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a product with user-specific flexible price information
         * @param {ProductsApiProductsUserFlexiblePriceRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        productsUserFlexiblePriceRetrieve(requestParameters, options) {
            return localVarFp.productsUserFlexiblePriceRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    productsAllCreate(requestParameters, options) {
        return ProductsApiFp(this.configuration).productsAllCreate(requestParameters.ProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    productsAllDestroy(requestParameters, options) {
        return ProductsApiFp(this.configuration).productsAllDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    productsAllList(requestParameters = {}, options) {
        return ProductsApiFp(this.configuration).productsAllList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    productsAllPartialUpdate(requestParameters, options) {
        return ProductsApiFp(this.configuration).productsAllPartialUpdate(requestParameters.id, requestParameters.PatchedProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    productsAllRetrieve(requestParameters, options) {
        return ProductsApiFp(this.configuration).productsAllRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * This doesn\'t filter unenrollable products out, and adds name search for courseware object readable id. It\'s really for the staff dashboard.
     * @param {ProductsApiProductsAllUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    productsAllUpdate(requestParameters, options) {
        return ProductsApiFp(this.configuration).productsAllUpdate(requestParameters.id, requestParameters.ProductRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List and view products within the system.
     * @param {ProductsApiProductsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    productsList(requestParameters = {}, options) {
        return ProductsApiFp(this.configuration).productsList(requestParameters.limit, requestParameters.offset, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List and view products within the system.
     * @param {ProductsApiProductsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    productsRetrieve(requestParameters, options) {
        return ProductsApiFp(this.configuration).productsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a product with user-specific flexible price information
     * @param {ProductsApiProductsUserFlexiblePriceRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    productsUserFlexiblePriceRetrieve(requestParameters, options) {
        return ProductsApiFp(this.configuration).productsUserFlexiblePriceRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ProgramCertificatesApi - axios parameter creator
 * @export
 */
export const ProgramCertificatesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Get a program certificate by UUID.
         * @param {string} cert_uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCertificatesRetrieve: (cert_uuid_1, ...args_1) => __awaiter(this, [cert_uuid_1, ...args_1], void 0, function* (cert_uuid, options = {}) {
            // verify required parameter 'cert_uuid' is not null or undefined
            assertParamExists('programCertificatesRetrieve', 'cert_uuid', cert_uuid);
            const localVarPath = `/api/v2/program_certificates/{cert_uuid}/`
                .replace(`{${"cert_uuid"}}`, encodeURIComponent(String(cert_uuid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProgramCertificatesApi - functional programming interface
 * @export
 */
export const ProgramCertificatesApiFp = function (configuration) {
    const localVarAxiosParamCreator = ProgramCertificatesApiAxiosParamCreator(configuration);
    return {
        /**
         * Get a program certificate by UUID.
         * @param {string} cert_uuid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCertificatesRetrieve(cert_uuid, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.programCertificatesRetrieve(cert_uuid, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramCertificatesApi.programCertificatesRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * ProgramCertificatesApi - factory interface
 * @export
 */
export const ProgramCertificatesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ProgramCertificatesApiFp(configuration);
    return {
        /**
         * Get a program certificate by UUID.
         * @param {ProgramCertificatesApiProgramCertificatesRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCertificatesRetrieve(requestParameters, options) {
            return localVarFp.programCertificatesRetrieve(requestParameters.cert_uuid, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProgramCertificatesApi - object-oriented interface
 * @export
 * @class ProgramCertificatesApi
 * @extends {BaseAPI}
 */
export class ProgramCertificatesApi extends BaseAPI {
    /**
     * Get a program certificate by UUID.
     * @param {ProgramCertificatesApiProgramCertificatesRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramCertificatesApi
     */
    programCertificatesRetrieve(requestParameters, options) {
        return ProgramCertificatesApiFp(this.configuration).programCertificatesRetrieve(requestParameters.cert_uuid, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ProgramCollectionsApi - axios parameter creator
 * @export
 */
export const ProgramCollectionsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [page_size] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCollectionsList: (page_1, page_size_1, ...args_1) => __awaiter(this, [page_1, page_size_1, ...args_1], void 0, function* (page, page_size, options = {}) {
            const localVarPath = `/api/v2/program-collections/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {number} id A unique integer value identifying this Program Collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCollectionsRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('programCollectionsRetrieve', 'id', id);
            const localVarPath = `/api/v2/program-collections/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProgramCollectionsApi - functional programming interface
 * @export
 */
export const ProgramCollectionsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ProgramCollectionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [page_size] Number of results to return per page.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCollectionsList(page, page_size, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.programCollectionsList(page, page_size, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramCollectionsApi.programCollectionsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {number} id A unique integer value identifying this Program Collection.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCollectionsRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.programCollectionsRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramCollectionsApi.programCollectionsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * ProgramCollectionsApi - factory interface
 * @export
 */
export const ProgramCollectionsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ProgramCollectionsApiFp(configuration);
    return {
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {ProgramCollectionsApiProgramCollectionsListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCollectionsList(requestParameters = {}, options) {
            return localVarFp.programCollectionsList(requestParameters.page, requestParameters.page_size, options).then((request) => request(axios, basePath));
        },
        /**
         * Readonly viewset for ProgramCollection objects.
         * @param {ProgramCollectionsApiProgramCollectionsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programCollectionsRetrieve(requestParameters, options) {
            return localVarFp.programCollectionsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProgramCollectionsApi - object-oriented interface
 * @export
 * @class ProgramCollectionsApi
 * @extends {BaseAPI}
 */
export class ProgramCollectionsApi extends BaseAPI {
    /**
     * Readonly viewset for ProgramCollection objects.
     * @param {ProgramCollectionsApiProgramCollectionsListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramCollectionsApi
     */
    programCollectionsList(requestParameters = {}, options) {
        return ProgramCollectionsApiFp(this.configuration).programCollectionsList(requestParameters.page, requestParameters.page_size, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Readonly viewset for ProgramCollection objects.
     * @param {ProgramCollectionsApiProgramCollectionsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramCollectionsApi
     */
    programCollectionsRetrieve(requestParameters, options) {
        return ProgramCollectionsApiFp(this.configuration).programCollectionsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ProgramEnrollmentsApi - axios parameter creator
 * @export
 */
export const ProgramEnrollmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsDestroy: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('programEnrollmentsDestroy', 'id', id);
            const localVarPath = `/api/v1/program_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a unified set of program and course enrollments for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsList: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v1/program_enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a specific program enrollment.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('programEnrollmentsRetrieve', 'id', id);
            const localVarPath = `/api/v1/program_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsDestroy: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v2ProgramEnrollmentsDestroy', 'id', id);
            const localVarPath = `/api/v2/program_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'DELETE' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a unified set of program and course enrollments for the current user using v2 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsList: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v2/program_enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Retrieve a specific program enrollment using v2 serializers.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('v2ProgramEnrollmentsRetrieve', 'id', id);
            const localVarPath = `/api/v2/program_enrollments/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ProgramEnrollmentsList: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v3/program_enrollments/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {number} program_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ProgramEnrollmentsRetrieve: (program_id_1, ...args_1) => __awaiter(this, [program_id_1, ...args_1], void 0, function* (program_id, options = {}) {
            // verify required parameter 'program_id' is not null or undefined
            assertParamExists('v3ProgramEnrollmentsRetrieve', 'program_id', program_id);
            const localVarPath = `/api/v3/program_enrollments/{program_id}/`
                .replace(`{${"program_id"}}`, encodeURIComponent(String(program_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProgramEnrollmentsApi - functional programming interface
 * @export
 */
export const ProgramEnrollmentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ProgramEnrollmentsApiAxiosParamCreator(configuration);
    return {
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsDestroy(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.programEnrollmentsDestroy(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramEnrollmentsApi.programEnrollmentsDestroy']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns a unified set of program and course enrollments for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.programEnrollmentsList(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramEnrollmentsApi.programEnrollmentsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Retrieve a specific program enrollment.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.programEnrollmentsRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramEnrollmentsApi.programEnrollmentsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsDestroy(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.v2ProgramEnrollmentsDestroy(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramEnrollmentsApi.v2ProgramEnrollmentsDestroy']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Returns a unified set of program and course enrollments for the current user using v2 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.v2ProgramEnrollmentsList(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramEnrollmentsApi.v2ProgramEnrollmentsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Retrieve a specific program enrollment using v2 serializers.
         * @param {number} id Program enrollment ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.v2ProgramEnrollmentsRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramEnrollmentsApi.v2ProgramEnrollmentsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ProgramEnrollmentsList(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.v3ProgramEnrollmentsList(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramEnrollmentsApi.v3ProgramEnrollmentsList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {number} program_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ProgramEnrollmentsRetrieve(program_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.v3ProgramEnrollmentsRetrieve(program_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramEnrollmentsApi.v3ProgramEnrollmentsRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * ProgramEnrollmentsApi - factory interface
 * @export
 */
export const ProgramEnrollmentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ProgramEnrollmentsApiFp(configuration);
    return {
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {ProgramEnrollmentsApiProgramEnrollmentsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsDestroy(requestParameters, options) {
            return localVarFp.programEnrollmentsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a unified set of program and course enrollments for the current user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsList(options) {
            return localVarFp.programEnrollmentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific program enrollment.
         * @param {ProgramEnrollmentsApiProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programEnrollmentsRetrieve(requestParameters, options) {
            return localVarFp.programEnrollmentsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
         * @param {ProgramEnrollmentsApiV2ProgramEnrollmentsDestroyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsDestroy(requestParameters, options) {
            return localVarFp.v2ProgramEnrollmentsDestroy(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a unified set of program and course enrollments for the current user using v2 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsList(options) {
            return localVarFp.v2ProgramEnrollmentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a specific program enrollment using v2 serializers.
         * @param {ProgramEnrollmentsApiV2ProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v2ProgramEnrollmentsRetrieve(requestParameters, options) {
            return localVarFp.v2ProgramEnrollmentsRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ProgramEnrollmentsList(options) {
            return localVarFp.v3ProgramEnrollmentsList(options).then((request) => request(axios, basePath));
        },
        /**
         * ViewSet for user program enrollments with v3 serializers.
         * @param {ProgramEnrollmentsApiV3ProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        v3ProgramEnrollmentsRetrieve(requestParameters, options) {
            return localVarFp.v3ProgramEnrollmentsRetrieve(requestParameters.program_id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProgramEnrollmentsApi - object-oriented interface
 * @export
 * @class ProgramEnrollmentsApi
 * @extends {BaseAPI}
 */
export class ProgramEnrollmentsApi extends BaseAPI {
    /**
     * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
     * @param {ProgramEnrollmentsApiProgramEnrollmentsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    programEnrollmentsDestroy(requestParameters, options) {
        return ProgramEnrollmentsApiFp(this.configuration).programEnrollmentsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a unified set of program and course enrollments for the current user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    programEnrollmentsList(options) {
        return ProgramEnrollmentsApiFp(this.configuration).programEnrollmentsList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a specific program enrollment.
     * @param {ProgramEnrollmentsApiProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    programEnrollmentsRetrieve(requestParameters, options) {
        return ProgramEnrollmentsApiFp(this.configuration).programEnrollmentsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Unenroll the user from this program. This is simpler than the corresponding function for CourseRunEnrollments; edX doesn\'t really know what programs are so there\'s nothing to process there.
     * @param {ProgramEnrollmentsApiV2ProgramEnrollmentsDestroyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    v2ProgramEnrollmentsDestroy(requestParameters, options) {
        return ProgramEnrollmentsApiFp(this.configuration).v2ProgramEnrollmentsDestroy(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a unified set of program and course enrollments for the current user using v2 serializers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    v2ProgramEnrollmentsList(options) {
        return ProgramEnrollmentsApiFp(this.configuration).v2ProgramEnrollmentsList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Retrieve a specific program enrollment using v2 serializers.
     * @param {ProgramEnrollmentsApiV2ProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    v2ProgramEnrollmentsRetrieve(requestParameters, options) {
        return ProgramEnrollmentsApiFp(this.configuration).v2ProgramEnrollmentsRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * ViewSet for user program enrollments with v3 serializers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    v3ProgramEnrollmentsList(options) {
        return ProgramEnrollmentsApiFp(this.configuration).v3ProgramEnrollmentsList(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * ViewSet for user program enrollments with v3 serializers.
     * @param {ProgramEnrollmentsApiV3ProgramEnrollmentsRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramEnrollmentsApi
     */
    v3ProgramEnrollmentsRetrieve(requestParameters, options) {
        return ProgramEnrollmentsApiFp(this.configuration).v3ProgramEnrollmentsRetrieve(requestParameters.program_id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ProgramsApi - axios parameter creator
 * @export
 */
export const ProgramsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * List Programs - v1
         * @param {number} [id]
         * @param {boolean} [live]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsListV1: (id_1, live_1, page_1, page_size_1, readable_id_1, ...args_1) => __awaiter(this, [id_1, live_1, page_1, page_size_1, readable_id_1, ...args_1], void 0, function* (id, live, page, page_size, readable_id, options = {}) {
            const localVarPath = `/api/v1/programs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (live !== undefined) {
                localVarQueryParameter['live'] = live;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }
            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List Programs - v2
         * @param {number} [contract_id]
         * @param {Array<number>} [id] Multiple values may be separated by commas.
         * @param {boolean} [live]
         * @param {number} [org_id]
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live]
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsListV2: (contract_id_1, id_1, live_1, org_id_1, page_1, page__live_1, page_size_1, readable_id_1, ...args_1) => __awaiter(this, [contract_id_1, id_1, live_1, org_id_1, page_1, page__live_1, page_size_1, readable_id_1, ...args_1], void 0, function* (contract_id, id, live, org_id, page, page__live, page_size, readable_id, options = {}) {
            const localVarPath = `/api/v2/programs/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (contract_id !== undefined) {
                localVarQueryParameter['contract_id'] = contract_id;
            }
            if (id) {
                localVarQueryParameter['id'] = id.join(COLLECTION_FORMATS.csv);
            }
            if (live !== undefined) {
                localVarQueryParameter['live'] = live;
            }
            if (org_id !== undefined) {
                localVarQueryParameter['org_id'] = org_id;
            }
            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }
            if (page__live !== undefined) {
                localVarQueryParameter['page__live'] = page__live;
            }
            if (page_size !== undefined) {
                localVarQueryParameter['page_size'] = page_size;
            }
            if (readable_id !== undefined) {
                localVarQueryParameter['readable_id'] = readable_id;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Programs - v1
         * @param {number} id A unique integer value identifying this program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRetrieveV1: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('programsRetrieveV1', 'id', id);
            const localVarPath = `/api/v1/programs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * API view set for Programs - v2
         * @param {number} id A unique integer value identifying this program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRetrieveV2: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('programsRetrieveV2', 'id', id);
            const localVarPath = `/api/v2/programs/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * ProgramsApi - functional programming interface
 * @export
 */
export const ProgramsApiFp = function (configuration) {
    const localVarAxiosParamCreator = ProgramsApiAxiosParamCreator(configuration);
    return {
        /**
         * List Programs - v1
         * @param {number} [id]
         * @param {boolean} [live]
         * @param {number} [page] A page number within the paginated result set.
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsListV1(id, live, page, page_size, readable_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.programsListV1(id, live, page, page_size, readable_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramsApi.programsListV1']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * List Programs - v2
         * @param {number} [contract_id]
         * @param {Array<number>} [id] Multiple values may be separated by commas.
         * @param {boolean} [live]
         * @param {number} [org_id]
         * @param {number} [page] A page number within the paginated result set.
         * @param {boolean} [page__live]
         * @param {number} [page_size] Number of results to return per page.
         * @param {string} [readable_id]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsListV2(contract_id, id, live, org_id, page, page__live, page_size, readable_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.programsListV2(contract_id, id, live, org_id, page, page__live, page_size, readable_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramsApi.programsListV2']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Programs - v1
         * @param {number} id A unique integer value identifying this program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRetrieveV1(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.programsRetrieveV1(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramsApi.programsRetrieveV1']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * API view set for Programs - v2
         * @param {number} id A unique integer value identifying this program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRetrieveV2(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.programsRetrieveV2(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['ProgramsApi.programsRetrieveV2']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * ProgramsApi - factory interface
 * @export
 */
export const ProgramsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ProgramsApiFp(configuration);
    return {
        /**
         * List Programs - v1
         * @param {ProgramsApiProgramsListV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsListV1(requestParameters = {}, options) {
            return localVarFp.programsListV1(requestParameters.id, requestParameters.live, requestParameters.page, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * List Programs - v2
         * @param {ProgramsApiProgramsListV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsListV2(requestParameters = {}, options) {
            return localVarFp.programsListV2(requestParameters.contract_id, requestParameters.id, requestParameters.live, requestParameters.org_id, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Programs - v1
         * @param {ProgramsApiProgramsRetrieveV1Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRetrieveV1(requestParameters, options) {
            return localVarFp.programsRetrieveV1(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * API view set for Programs - v2
         * @param {ProgramsApiProgramsRetrieveV2Request} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        programsRetrieveV2(requestParameters, options) {
            return localVarFp.programsRetrieveV2(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ProgramsApi - object-oriented interface
 * @export
 * @class ProgramsApi
 * @extends {BaseAPI}
 */
export class ProgramsApi extends BaseAPI {
    /**
     * List Programs - v1
     * @param {ProgramsApiProgramsListV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    programsListV1(requestParameters = {}, options) {
        return ProgramsApiFp(this.configuration).programsListV1(requestParameters.id, requestParameters.live, requestParameters.page, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * List Programs - v2
     * @param {ProgramsApiProgramsListV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    programsListV2(requestParameters = {}, options) {
        return ProgramsApiFp(this.configuration).programsListV2(requestParameters.contract_id, requestParameters.id, requestParameters.live, requestParameters.org_id, requestParameters.page, requestParameters.page__live, requestParameters.page_size, requestParameters.readable_id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Programs - v1
     * @param {ProgramsApiProgramsRetrieveV1Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    programsRetrieveV1(requestParameters, options) {
        return ProgramsApiFp(this.configuration).programsRetrieveV1(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * API view set for Programs - v2
     * @param {ProgramsApiProgramsRetrieveV2Request} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProgramsApi
     */
    programsRetrieveV2(requestParameters, options) {
        return ProgramsApiFp(this.configuration).programsRetrieveV2(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserSearchApi - axios parameter creator
 * @export
 */
export const UserSearchApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {number} [l] Number of results to return per page.
         * @param {number} [o] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearchList: (l_1, o_1, search_1, ...args_1) => __awaiter(this, [l_1, o_1, search_1, ...args_1], void 0, function* (l, o, search, options = {}) {
            const localVarPath = `/api/v0/user_search/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (l !== undefined) {
                localVarQueryParameter['l'] = l;
            }
            if (o !== undefined) {
                localVarQueryParameter['o'] = o;
            }
            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearchRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('userSearchRetrieve', 'id', id);
            const localVarPath = `/api/v0/user_search/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UserSearchApi - functional programming interface
 * @export
 */
export const UserSearchApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserSearchApiAxiosParamCreator(configuration);
    return {
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {number} [l] Number of results to return per page.
         * @param {number} [o] The initial index from which to return the results.
         * @param {string} [search] A search term.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearchList(l, o, search, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.userSearchList(l, o, search, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['UserSearchApi.userSearchList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearchRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.userSearchRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['UserSearchApi.userSearchRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * UserSearchApi - factory interface
 * @export
 */
export const UserSearchApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserSearchApiFp(configuration);
    return {
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {UserSearchApiUserSearchListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearchList(requestParameters = {}, options) {
            return localVarFp.userSearchList(requestParameters.l, requestParameters.o, requestParameters.search, options).then((request) => request(axios, basePath));
        },
        /**
         * Provides an API for listing system users. This is for the staff dashboard.
         * @param {UserSearchApiUserSearchRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userSearchRetrieve(requestParameters, options) {
            return localVarFp.userSearchRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserSearchApi - object-oriented interface
 * @export
 * @class UserSearchApi
 * @extends {BaseAPI}
 */
export class UserSearchApi extends BaseAPI {
    /**
     * Provides an API for listing system users. This is for the staff dashboard.
     * @param {UserSearchApiUserSearchListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchApi
     */
    userSearchList(requestParameters = {}, options) {
        return UserSearchApiFp(this.configuration).userSearchList(requestParameters.l, requestParameters.o, requestParameters.search, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Provides an API for listing system users. This is for the staff dashboard.
     * @param {UserSearchApiUserSearchRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserSearchApi
     */
    userSearchRetrieve(requestParameters, options) {
        return UserSearchApiFp(this.configuration).userSearchRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UserinfoApi - axios parameter creator
 * @export
 */
export const UserinfoApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Retrieve the current user\'s info only if they have an edx_username, otherwise return 409  This is to prevent issues with Open edX OAuth client that expect an edx_username to be present
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfoRetrieve: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v0/userinfo/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UserinfoApi - functional programming interface
 * @export
 */
export const UserinfoApiFp = function (configuration) {
    const localVarAxiosParamCreator = UserinfoApiAxiosParamCreator(configuration);
    return {
        /**
         * Retrieve the current user\'s info only if they have an edx_username, otherwise return 409  This is to prevent issues with Open edX OAuth client that expect an edx_username to be present
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfoRetrieve(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.userinfoRetrieve(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['UserinfoApi.userinfoRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * UserinfoApi - factory interface
 * @export
 */
export const UserinfoApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UserinfoApiFp(configuration);
    return {
        /**
         * Retrieve the current user\'s info only if they have an edx_username, otherwise return 409  This is to prevent issues with Open edX OAuth client that expect an edx_username to be present
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userinfoRetrieve(options) {
            return localVarFp.userinfoRetrieve(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UserinfoApi - object-oriented interface
 * @export
 * @class UserinfoApi
 * @extends {BaseAPI}
 */
export class UserinfoApi extends BaseAPI {
    /**
     * Retrieve the current user\'s info only if they have an edx_username, otherwise return 409  This is to prevent issues with Open edX OAuth client that expect an edx_username to be present
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserinfoApi
     */
    userinfoRetrieve(options) {
        return UserinfoApiFp(this.configuration).userinfoRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * User retrieve and update viewsets for the current user
         * @param {PatchedUserRequest} [PatchedUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUserPartialUpdate: (PatchedUserRequest_1, ...args_1) => __awaiter(this, [PatchedUserRequest_1, ...args_1], void 0, function* (PatchedUserRequest, options = {}) {
            const localVarPath = `/api/v0/users/current_user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedUserRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUserRetrieve: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v0/users/current_user/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User retrieve and update viewsets for the current user
         * @param {PatchedUserRequest} [PatchedUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePartialUpdate: (PatchedUserRequest_1, ...args_1) => __awaiter(this, [PatchedUserRequest_1, ...args_1], void 0, function* (PatchedUserRequest, options = {}) {
            const localVarPath = `/api/v0/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'PATCH' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = serializeDataIfNeeded(PatchedUserRequest, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve: (...args_1) => __awaiter(this, [...args_1], void 0, function* (options = {}) {
            const localVarPath = `/api/v0/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * User retrieve viewsets
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve: (id_1, ...args_1) => __awaiter(this, [id_1, ...args_1], void 0, function* (id, options = {}) {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersRetrieve', 'id', id);
            const localVarPath = `/api/v0/users/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function (configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration);
    return {
        /**
         * User retrieve and update viewsets for the current user
         * @param {PatchedUserRequest} [PatchedUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUserPartialUpdate(PatchedUserRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.usersCurrentUserPartialUpdate(PatchedUserRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['UsersApi.usersCurrentUserPartialUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUserRetrieve(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.usersCurrentUserRetrieve(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['UsersApi.usersCurrentUserRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {PatchedUserRequest} [PatchedUserRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePartialUpdate(PatchedUserRequest, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.usersMePartialUpdate(PatchedUserRequest, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['UsersApi.usersMePartialUpdate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve(options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.usersMeRetrieve(options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['UsersApi.usersMeRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
        /**
         * User retrieve viewsets
         * @param {number} id A unique integer value identifying this user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.usersRetrieve(id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['UsersApi.usersRetrieve']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration, basePath, axios) {
    const localVarFp = UsersApiFp(configuration);
    return {
        /**
         * User retrieve and update viewsets for the current user
         * @param {UsersApiUsersCurrentUserPartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUserPartialUpdate(requestParameters = {}, options) {
            return localVarFp.usersCurrentUserPartialUpdate(requestParameters.PatchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUserRetrieve(options) {
            return localVarFp.usersCurrentUserRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {UsersApiUsersMePartialUpdateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMePartialUpdate(requestParameters = {}, options) {
            return localVarFp.usersMePartialUpdate(requestParameters.PatchedUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * User retrieve and update viewsets for the current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersMeRetrieve(options) {
            return localVarFp.usersMeRetrieve(options).then((request) => request(axios, basePath));
        },
        /**
         * User retrieve viewsets
         * @param {UsersApiUsersRetrieveRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersRetrieve(requestParameters, options) {
            return localVarFp.usersRetrieve(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * User retrieve and update viewsets for the current user
     * @param {UsersApiUsersCurrentUserPartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    usersCurrentUserPartialUpdate(requestParameters = {}, options) {
        return UsersApiFp(this.configuration).usersCurrentUserPartialUpdate(requestParameters.PatchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User retrieve and update viewsets for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    usersCurrentUserRetrieve(options) {
        return UsersApiFp(this.configuration).usersCurrentUserRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User retrieve and update viewsets for the current user
     * @param {UsersApiUsersMePartialUpdateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    usersMePartialUpdate(requestParameters = {}, options) {
        return UsersApiFp(this.configuration).usersMePartialUpdate(requestParameters.PatchedUserRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User retrieve and update viewsets for the current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    usersMeRetrieve(options) {
        return UsersApiFp(this.configuration).usersMeRetrieve(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * User retrieve viewsets
     * @param {UsersApiUsersRetrieveRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    usersRetrieve(requestParameters, options) {
        return UsersApiFp(this.configuration).usersRetrieve(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * VerifiableCourseCredentialApi - axios parameter creator
 * @export
 */
export const VerifiableCourseCredentialApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {string} credential_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiableCourseCredentialDownloadList: (credential_id_1, ...args_1) => __awaiter(this, [credential_id_1, ...args_1], void 0, function* (credential_id, options = {}) {
            // verify required parameter 'credential_id' is not null or undefined
            assertParamExists('verifiableCourseCredentialDownloadList', 'credential_id', credential_id);
            const localVarPath = `/api/v2/verifiable_course_credential/{credential_id}/download/`
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credential_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * VerifiableCourseCredentialApi - functional programming interface
 * @export
 */
export const VerifiableCourseCredentialApiFp = function (configuration) {
    const localVarAxiosParamCreator = VerifiableCourseCredentialApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {string} credential_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiableCourseCredentialDownloadList(credential_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.verifiableCourseCredentialDownloadList(credential_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['VerifiableCourseCredentialApi.verifiableCourseCredentialDownloadList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * VerifiableCourseCredentialApi - factory interface
 * @export
 */
export const VerifiableCourseCredentialApiFactory = function (configuration, basePath, axios) {
    const localVarFp = VerifiableCourseCredentialApiFp(configuration);
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {VerifiableCourseCredentialApiVerifiableCourseCredentialDownloadListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiableCourseCredentialDownloadList(requestParameters, options) {
            return localVarFp.verifiableCourseCredentialDownloadList(requestParameters.credential_id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * VerifiableCourseCredentialApi - object-oriented interface
 * @export
 * @class VerifiableCourseCredentialApi
 * @extends {BaseAPI}
 */
export class VerifiableCourseCredentialApi extends BaseAPI {
    /**
     * Returns the json for the verifiable credential with the given ID
     * @param {VerifiableCourseCredentialApiVerifiableCourseCredentialDownloadListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifiableCourseCredentialApi
     */
    verifiableCourseCredentialDownloadList(requestParameters, options) {
        return VerifiableCourseCredentialApiFp(this.configuration).verifiableCourseCredentialDownloadList(requestParameters.credential_id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * VerifiableProgramCredentialApi - axios parameter creator
 * @export
 */
export const VerifiableProgramCredentialApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {string} credential_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiableProgramCredentialDownloadList: (credential_id_1, ...args_1) => __awaiter(this, [credential_id_1, ...args_1], void 0, function* (credential_id, options = {}) {
            // verify required parameter 'credential_id' is not null or undefined
            assertParamExists('verifiableProgramCredentialDownloadList', 'credential_id', credential_id);
            const localVarPath = `/api/v2/verifiable_program_credential/{credential_id}/download/`
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credential_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'GET' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * VerifiableProgramCredentialApi - functional programming interface
 * @export
 */
export const VerifiableProgramCredentialApiFp = function (configuration) {
    const localVarAxiosParamCreator = VerifiableProgramCredentialApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {string} credential_id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiableProgramCredentialDownloadList(credential_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.verifiableProgramCredentialDownloadList(credential_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['VerifiableProgramCredentialApi.verifiableProgramCredentialDownloadList']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * VerifiableProgramCredentialApi - factory interface
 * @export
 */
export const VerifiableProgramCredentialApiFactory = function (configuration, basePath, axios) {
    const localVarFp = VerifiableProgramCredentialApiFp(configuration);
    return {
        /**
         * Returns the json for the verifiable credential with the given ID
         * @param {VerifiableProgramCredentialApiVerifiableProgramCredentialDownloadListRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiableProgramCredentialDownloadList(requestParameters, options) {
            return localVarFp.verifiableProgramCredentialDownloadList(requestParameters.credential_id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * VerifiableProgramCredentialApi - object-oriented interface
 * @export
 * @class VerifiableProgramCredentialApi
 * @extends {BaseAPI}
 */
export class VerifiableProgramCredentialApi extends BaseAPI {
    /**
     * Returns the json for the verifiable credential with the given ID
     * @param {VerifiableProgramCredentialApiVerifiableProgramCredentialDownloadListRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifiableProgramCredentialApi
     */
    verifiableProgramCredentialDownloadList(requestParameters, options) {
        return VerifiableProgramCredentialApiFp(this.configuration).verifiableProgramCredentialDownloadList(requestParameters.credential_id, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * VerifiedProgramEnrollmentsApi - axios parameter creator
 * @export
 */
export const VerifiedProgramEnrollmentsApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Create a program-related course enrollment for the learner.  Some special handling is needed for program-related course run enrollments when the learner has an enrollment in the program. The learner should get a course run enrollment that matches their program enrollment at no additional charge. However, if the learner is enrolling in a course that\'s an elective, and they have already enrolled in enough electives to satisfy the program\'s requirements, they should then get an audit enrollment. (This won\'t preclude them from getting a certificate for the course itself but they\'ll have to buy the upgrade separately.)
         * @param {string} courserun_id Readable ID for the course run to enroll in.
         * @param {string} program_id Readable ID for the program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiedProgramEnrollmentsCreate: (courserun_id_1, program_id_1, ...args_1) => __awaiter(this, [courserun_id_1, program_id_1, ...args_1], void 0, function* (courserun_id, program_id, options = {}) {
            // verify required parameter 'courserun_id' is not null or undefined
            assertParamExists('verifiedProgramEnrollmentsCreate', 'courserun_id', courserun_id);
            // verify required parameter 'program_id' is not null or undefined
            assertParamExists('verifiedProgramEnrollmentsCreate', 'program_id', program_id);
            const localVarPath = `/api/v2/verified_program_enrollments/{program_id}/{courserun_id}/`
                .replace(`{${"courserun_id"}}`, encodeURIComponent(String(courserun_id)))
                .replace(`{${"program_id"}}`, encodeURIComponent(String(program_id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: 'POST' }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
/**
 * VerifiedProgramEnrollmentsApi - functional programming interface
 * @export
 */
export const VerifiedProgramEnrollmentsApiFp = function (configuration) {
    const localVarAxiosParamCreator = VerifiedProgramEnrollmentsApiAxiosParamCreator(configuration);
    return {
        /**
         * Create a program-related course enrollment for the learner.  Some special handling is needed for program-related course run enrollments when the learner has an enrollment in the program. The learner should get a course run enrollment that matches their program enrollment at no additional charge. However, if the learner is enrolling in a course that\'s an elective, and they have already enrolled in enough electives to satisfy the program\'s requirements, they should then get an audit enrollment. (This won\'t preclude them from getting a certificate for the course itself but they\'ll have to buy the upgrade separately.)
         * @param {string} courserun_id Readable ID for the course run to enroll in.
         * @param {string} program_id Readable ID for the program.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiedProgramEnrollmentsCreate(courserun_id, program_id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                var _a, _b, _c;
                const localVarAxiosArgs = yield localVarAxiosParamCreator.verifiedProgramEnrollmentsCreate(courserun_id, program_id, options);
                const index = (_a = configuration === null || configuration === void 0 ? void 0 : configuration.serverIndex) !== null && _a !== void 0 ? _a : 0;
                const operationBasePath = (_c = (_b = operationServerMap['VerifiedProgramEnrollmentsApi.verifiedProgramEnrollmentsCreate']) === null || _b === void 0 ? void 0 : _b[index]) === null || _c === void 0 ? void 0 : _c.url;
                return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
            });
        },
    };
};
/**
 * VerifiedProgramEnrollmentsApi - factory interface
 * @export
 */
export const VerifiedProgramEnrollmentsApiFactory = function (configuration, basePath, axios) {
    const localVarFp = VerifiedProgramEnrollmentsApiFp(configuration);
    return {
        /**
         * Create a program-related course enrollment for the learner.  Some special handling is needed for program-related course run enrollments when the learner has an enrollment in the program. The learner should get a course run enrollment that matches their program enrollment at no additional charge. However, if the learner is enrolling in a course that\'s an elective, and they have already enrolled in enough electives to satisfy the program\'s requirements, they should then get an audit enrollment. (This won\'t preclude them from getting a certificate for the course itself but they\'ll have to buy the upgrade separately.)
         * @param {VerifiedProgramEnrollmentsApiVerifiedProgramEnrollmentsCreateRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifiedProgramEnrollmentsCreate(requestParameters, options) {
            return localVarFp.verifiedProgramEnrollmentsCreate(requestParameters.courserun_id, requestParameters.program_id, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * VerifiedProgramEnrollmentsApi - object-oriented interface
 * @export
 * @class VerifiedProgramEnrollmentsApi
 * @extends {BaseAPI}
 */
export class VerifiedProgramEnrollmentsApi extends BaseAPI {
    /**
     * Create a program-related course enrollment for the learner.  Some special handling is needed for program-related course run enrollments when the learner has an enrollment in the program. The learner should get a course run enrollment that matches their program enrollment at no additional charge. However, if the learner is enrolling in a course that\'s an elective, and they have already enrolled in enough electives to satisfy the program\'s requirements, they should then get an audit enrollment. (This won\'t preclude them from getting a certificate for the course itself but they\'ll have to buy the upgrade separately.)
     * @param {VerifiedProgramEnrollmentsApiVerifiedProgramEnrollmentsCreateRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VerifiedProgramEnrollmentsApi
     */
    verifiedProgramEnrollmentsCreate(requestParameters, options) {
        return VerifiedProgramEnrollmentsApiFp(this.configuration).verifiedProgramEnrollmentsCreate(requestParameters.courserun_id, requestParameters.program_id, options).then((request) => request(this.axios, this.basePath));
    }
}
//# sourceMappingURL=api.js.map